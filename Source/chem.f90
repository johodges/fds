!> \brief CVODE interface for detailed chemistry calculation
! CALL CVODE FOR SOLVING CHEMISTRY 
! THE DERIVATIVE AND JACOBIAN FUNCTION TRACK N_TRACKED_SPECIES+2
! VARIABLES. THE +2 IS TEMPERATURE AND PRESSURE.

!> @cond DOXYGEN_IGNORE
#ifdef WITH_SUNDIALS
!> @endcond


MODULE CVODE_INTERFACE

USE PRECISION_PARAMETERS
USE GLOBAL_CONSTANTS   
USE TYPES
USE CHEMCONS
USE, INTRINSIC :: ISO_C_BINDING

IMPLICIT NONE

TYPE :: USERDATA
    REAL(EB) :: ZETA0 ! initial unmixed fraction
    REAL(EB) :: TAU_MIX ! Mixing time scale
    REAL(EB) :: CELL_MASS ! Total mass of the cell (mixed + unmixed)
    REAL(EB), ALLOCATABLE, DIMENSION(:) :: ZZ_0  ! Initial mass fraction or mass fraction of unmixed zone.
    REAL(EB) :: H_IN ! Enthalpy of the intial mass fraction
END TYPE USERDATA

LOGICAL :: DEBUG=.FALSE.
REAL(EB), PARAMETER :: MIN_CHEM_TMP=200._EB
REAL(EB) :: CUR_CFD_TIME

PUBLIC CVODE_SERIAL

CONTAINS


!> \brief The right hand side function of the ode d[c]/dt = wdot (=f).
!> \param TN_C is the current time
!> \param SUNVEC_Y is the current array of molar concentrations, temperature and pressure.
!> \param SUNVEC_F is the array of derivatives returned
!> \param USER_DATA is the user data array. Not yet used in FDS.
!> \details The right hand side function of the ode d[c]/dt = wdot (=f). Provides the Derivative function to CVODE.
INTEGER(C_INT) FUNCTION RHSFN(TN_C, SUNVEC_Y, SUNVEC_F, C_USER_DATA) &
    RESULT(IERR) BIND(C,NAME='RHSFN')

USE FSUNDIALS_NVECTOR_MOD

! CALLING VARIABLES
REAL(C_DOUBLE), VALUE :: TN_C      ! CURRENT TIME
TYPE(N_VECTOR)        :: SUNVEC_Y  ! SOLUTION N_VECTOR
TYPE(N_VECTOR)        :: SUNVEC_F  ! RHS N_VECTOR
TYPE(C_PTR),    VALUE :: C_USER_DATA ! USER-DEFINED DATA

! POINTERS TO DATA IN SUNDIALS VECTORS
REAL(EB) :: TN ! Current time
REAL(EB), POINTER :: CVEC(:)
REAL(EB), POINTER :: FVEC(:)
TYPE(USERDATA), POINTER :: USER_DATA

! TO PREVENT UNUSED VARIABLE WARNING
IF (DEBUG) THEN
   WRITE(LU_ERR,*)"TIME = ",TN_C
   IF (.NOT. C_ASSOCIATED(C_USER_DATA)) WRITE(LU_ERR,*)" NO USER_DATA IS PROVIDED"
ENDIF

! GET DATA ARRAYS FROM SUNDIALS VECTORS
TN = REAL(TN_C, KIND=KIND(EB)) 
CVEC => FN_VGETARRAYPOINTER(SUNVEC_Y)
FVEC => FN_VGETARRAYPOINTER(SUNVEC_F)

CALL C_F_POINTER(C_USER_DATA, USER_DATA)

FVEC = 0._EB
CALL DERIVATIVE(CVEC, FVEC, TN, USER_DATA)


IERR = 0
RETURN

END FUNCTION RHSFN



!> \brief Calculate derivative (fvec) for a given concentration vector cvec(n_tracked_species+2)
!> \param CVEC is the current array of molar concentrations, temperature and pressure.
!> \param FVEC is the array of derivatives returned
!> \param TN is the current time
!> \param USER_DATA is the user data containing mixing information

SUBROUTINE DERIVATIVE(CVEC,FVEC, TN, USER_DATA)
USE PHYSICAL_FUNCTIONS, ONLY : GET_SPECIFIC_HEAT_INTERP, GET_ENTHALPY, GET_ENTHALPY_Z, &
         MOLAR_CONC_TO_MASS_FRAC, GET_MOLECULAR_WEIGHT

REAL(EB), POINTER, INTENT(INOUT)  :: CVEC(:)
REAL(EB), POINTER, INTENT(INOUT) :: FVEC(:)
REAL(EB), INTENT(IN) :: TN
TYPE(USERDATA), INTENT(IN):: USER_DATA

REAL(EB) :: R_F,MIN_SPEC(N_TRACKED_SPECIES), KG,  TMP, RHO, &
          K_0, K_INF, P_RI, FCENT, B_I, RRTMP, THIRD_BODY_ENHANCEMENT, PR
INTEGER :: I,NS, ITMP
REAL(EB) :: ZZ(N_TRACKED_SPECIES), CP, HS_I, DG, TMPI
REAL(EB) :: ZETA, MIXING_FACTOR, VOL_CHANGE_TERM, SUM_OMEGA_DOT, SUM_CC, MW0, MW, SUM_H_ZZ0, EXPONENT, CONC
TYPE(REACTION_TYPE), POINTER :: RN

TMP = MAX(CVEC(N_TRACKED_SPECIES+1), MIN_CHEM_TMP)
TMPI = 1._EB/TMP
PR = CVEC(N_TRACKED_SPECIES+2) ! PA
RRTMP = 1._EB/(R0*TMP)
ZETA = USER_DATA%ZETA0*EXP(-TN/USER_DATA%TAU_MIX)
MIXING_FACTOR = 0._EB
IF (ZETA < 1._EB) MIXING_FACTOR = ZETA/(1-ZETA)/USER_DATA%TAU_MIX

CALL GET_MOLECULAR_WEIGHT(USER_DATA%ZZ_0,MW0)
IF (ANY(CVEC(1:N_TRACKED_SPECIES) >0)) THEN 
   RHO = DOT_PRODUCT(SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%MW,CVEC(1:N_TRACKED_SPECIES))
   CALL MOLAR_CONC_TO_MASS_FRAC(CVEC(1:N_TRACKED_SPECIES), ZZ(1:N_TRACKED_SPECIES))
   CALL GET_MOLECULAR_WEIGHT(ZZ(1:N_TRACKED_SPECIES),MW)
ELSE ! Enters at the first timestep when ZETA0=1.
   RHO = PR*MW0/R0/TMP
   MW = MW0
   ZZ(1:N_TRACKED_SPECIES) = USER_DATA%ZZ_0(1:N_TRACKED_SPECIES)
ENDIF
MIN_SPEC = SPECIES_MIXTURE%ODE_REL_ERROR*ZZ_MIN_GLOBAL

REACTION_LOOP: DO I=1,N_REACTIONS
   RN => REACTION(I)
   ! CHECK FOR CONSUMED SPECIES
   DO NS=1,RN%N_SMIX_FR
      IF (RN%NU_MW_O_MW_F_FR(NS) < 0._EB .AND. CVEC(RN%NU_INDEX(NS)) < MIN_SPEC(NS)) CYCLE REACTION_LOOP
   ENDDO

   ! CALCULATE FORWARD RATE COEFF.
   K_INF = RN%A_SI*TMP**RN%N_T*EXP(-RN%E*RRTMP) !A_SI IS IN [KMOL/M3]^() UNIT.
   R_F = K_INF
   IF(RN%REVERSE) THEN ! COMPUTE EQUILIBRIUM CONSTANT
      ITMP = MAX(MIN(I_MAX_TEMP-1,INT(TMP)),0)
      DG = RN%DELTA_G(ITMP) + (TMP-REAL(ITMP,EB))*(RN%DELTA_G(ITMP+1)-RN%DELTA_G(ITMP))
      KG = EXP(DG/TMP)*(P_STP*RRTMP)**RN%C0_EXP
      R_F = R_F*KG ! KG IS THE CONCENTRATION EQUILIBRIUM CONSTANT OF REVERSE REACTION. 
   ENDIF

   ! MULTIPLY WITH MOLAR_CONCENTRATION ^ STOICHIOMETRIC_COEFF
   DO NS=1,RN%N_SPEC
      IF (CVEC(YP2ZZ(RN%N_S_INDEX(NS))) < MIN_SPEC(YP2ZZ(RN%N_S_INDEX(NS)))) CYCLE REACTION_LOOP
      EXPONENT = RN%N_S(NS)
      CONC = CVEC(YP2ZZ(RN%N_S_INDEX(NS)))
      IF (EXPONENT < 1._EB) THEN
         R_F = R_F * CONC**(EXPONENT - 1._EB)
         R_F = R_F * CONC
      ELSE
          R_F = R_F * CONC**EXPONENT
      END IF
   ENDDO

   ! CALCULATE B_I BASED ON TYPE OF REACTION
   IF (RN%THIRD_BODY) THEN

      IF (RN%N_THIRD > 0) THEN
         THIRD_BODY_ENHANCEMENT = DOT_PRODUCT(CVEC(1:N_SPECIES),RN%THIRD_EFF(1:N_SPECIES))
      ELSE
         THIRD_BODY_ENHANCEMENT = PR*RRTMP
      ENDIF

      IF (RN%REACTYPE==THREE_BODY_ARRHENIUS_TYPE) THEN
         R_F = R_F * THIRD_BODY_ENHANCEMENT
      ELSEIF(RN%REACTYPE==FALLOFF_LINDEMANN_TYPE .OR. RN%REACTYPE==FALLOFF_TROE_TYPE ) THEN
         K_0 = RN%A_LOW_PR*TMP**(RN%N_T_LOW_PR)*EXP(-RN%E_LOW_PR*RRTMP)
         P_RI = K_0/K_INF*THIRD_BODY_ENHANCEMENT
         FCENT = CALCFCENT(TMP,P_RI, I)
         B_I = P_RI/(1._EB+P_RI)*FCENT
         R_F = R_F * B_I
      ENDIF 
   ENDIF

   IF (DEBUG) WRITE(LU_ERR,*)"RN%ID, RATE-CONTRIB=", RN%ID, R_F

   ! ADD CONTRIBUTION OF THE REACTION TO THE FVEC
   DO NS=1,RN%N_SMIX_FR
     FVEC(RN%NU_INDEX(NS)) = FVEC(RN%NU_INDEX(NS)) + RN%NU_NN(RN%NU_INDEX(NS)) * R_F
   ENDDO

ENDDO REACTION_LOOP

! CALCULATE TEMPERATURE DERIVATIVE
CALL GET_SPECIFIC_HEAT_INTERP(ZZ(1:N_TRACKED_SPECIES),CP,TMP)
SUM_H_ZZ0 = 0._EB
DO NS=1,N_TRACKED_SPECIES
   CALL GET_ENTHALPY_Z(NS, TMP,HS_I)
   SUM_H_ZZ0 = SUM_H_ZZ0+HS_I*USER_DATA%ZZ_0(NS) ! Needed later.
   HS_I = HS_I * SPECIES_MIXTURE(NS)%MW ! To convert J/kg to J/kmol (absolute enthalpy includes enthalpy of formation)
   FVEC(N_TRACKED_SPECIES+1)= FVEC(N_TRACKED_SPECIES+1) + HS_I*FVEC(NS)   
ENDDO
! The first term is due to chemistry production rate and the second term is due to mixing.
FVEC(N_TRACKED_SPECIES+1)=-(FVEC(N_TRACKED_SPECIES+1) + (RHO*(SUM_H_ZZ0-USER_DATA%H_IN))*MIXING_FACTOR)/RHO/CP

! SO FAR FVEC(1:N_TRACKED_SPECIES) CONTAINS CHEMISTRY PRODUCTION RATE TERM (OMEGA_DOT). 
! THE FVEC(N_TRACKED_SPECIES+1) CONTAINS TOTAL TEMPERATURE DERIVATIVE (due to chemistry and mixing).

! NOW CALCULATE THE VOLUME CHANGE TERM
SUM_OMEGA_DOT = SUM(FVEC(1:N_TRACKED_SPECIES))
SUM_CC = SUM(CVEC(1:N_TRACKED_SPECIES))
VOL_CHANGE_TERM = 0._EB
IF (SUM_CC > 0._EB) THEN
   VOL_CHANGE_TERM = SUM_OMEGA_DOT/SUM_CC+TMPI*FVEC(N_TRACKED_SPECIES+1)+MW/MW0*MIXING_FACTOR
ENDIF

! ADD THE CONTRIBUTION DUE TO MIXING AND VOLUME CHANGE IN CONCENTRATION DERIVATIVE.
DO NS=1,N_TRACKED_SPECIES
   FVEC(NS) = FVEC(NS) + RHO * USER_DATA%ZZ_0(NS)/SPECIES_MIXTURE(NS)%MW*MIXING_FACTOR - CVEC(NS)*VOL_CHANGE_TERM
ENDDO

! PRESSURE DERIVATIVE (CONSTANT PRESSURE ASSUMPTION)
FVEC(N_TRACKED_SPECIES+2) = 0._EB

END SUBROUTINE DERIVATIVE


!> \brief Calculate fall-off function 
!> \param TMP is the current temperature.
!> \param P_RI is the reduced pressure
!> \param RNI is the index of reaction

REAL(EB) FUNCTION CALCFCENT(TMP, P_RI, RNI)
REAL(EB), INTENT(IN) :: TMP, P_RI
INTEGER, INTENT(IN) :: RNI
TYPE(REACTION_TYPE), POINTER :: RN
REAL(EB) :: LOGFCENT, C, N, LOGPRC
REAL(EB), PARAMETER :: D=0.14_EB

RN => REACTION(RNI)
IF(RN%REACTYPE==FALLOFF_TROE_TYPE) THEN
   IF (RN%T2_TROE <-1.E20_EB) THEN
      LOGFCENT = LOG10(MAX((1 - RN%A_TROE)*EXP(-TMP*RN%RT3_TROE) + &
                 RN%A_TROE*EXP(-TMP*RN%RT1_TROE),TWO_EPSILON_EB))
   ELSE
      LOGFCENT = LOG10(MAX((1 - RN%A_TROE)*EXP(-TMP*RN%RT3_TROE) + &
                 RN%A_TROE*EXP(-TMP*RN%RT1_TROE) + EXP(-RN%T2_TROE/TMP),TWO_EPSILON_EB))
   ENDIF
   C = -0.4_EB - 0.67_EB*LOGFCENT
   N = 0.75_EB - 1.27_EB*LOGFCENT
   LOGPRC = LOG10(MAX(P_RI, TWO_EPSILON_EB)) + C
   CALCFCENT = 10._EB**(LOGFCENT/(1._EB + (LOGPRC/(N - D*LOGPRC))**2))
ELSE
   CALCFCENT = 1._EB  !FALLOFF-LINDEMANNN
ENDIF

RETURN

END FUNCTION CALCFCENT




!> \brief The jacobian of the ode right hand side function j = df/dy
!> \param TN_C is the current time provided by CVODE during callback, not the actual CFD time.
!> \param SUNVEC_Y is the current array of molar concentrations, temperature and pressure.
!> \param SUNVEC_F is the array of derivatives returned
!> \param SUNMAT_J is the Jacobian array returned to CVODE
!> \param USER_DATA is the user data array. Not yet used in FDS.
!> \param TMP1 is not yet used in FDS.
!> \param TMP2 is not yet used in FDS.
!> \param TMP3 is not yet used in FDS.
!> \details The jacobian of the ode right hand side function j = df/dy. Provides the Jacobian function to CVODE.

INTEGER(C_INT) FUNCTION JACFN(TN_C, SUNVEC_Y, SUNVEC_F, SUNMAT_J, &
 C_USER_DATA, TMP1, TMP2, TMP3) &
 RESULT(IERR) BIND(C,NAME='JACFN')

USE FSUNDIALS_NVECTOR_MOD
USE FSUNMATRIX_DENSE_MOD
USE FSUNDIALS_MATRIX_MOD

! CALLING VARIABLES
REAL(C_DOUBLE), VALUE :: TN_C             ! CURRENT TIME
TYPE(N_VECTOR)        :: SUNVEC_Y         ! CURRENT SOLUTION N_VECTOR
TYPE(N_VECTOR)        :: SUNVEC_F         ! CURRENT RHS N_VECTOR
TYPE(SUNMATRIX)       :: SUNMAT_J         ! JACOBIAN SUNMATRIX
TYPE(C_PTR), VALUE    :: C_USER_DATA      ! USER-DEFINED DATA
TYPE(N_VECTOR)        :: TMP1, TMP2, TMP3 ! WORKSPACE N_VECTORS

! POINTER TO DATA IN SUNDIALS MATRIX
REAL(EB) :: TN ! Current time
REAL(EB), POINTER :: CVEC(:)
REAL(EB), POINTER :: FVEC(:)
REAL(EB), POINTER :: JMAT1D(:)
REAL(EB) :: JMAT(N_TRACKED_SPECIES+2, N_TRACKED_SPECIES+2)
REAL(EB), POINTER :: DUMMY(:)
TYPE(USERDATA), POINTER :: USER_DATA

INTEGER :: NS1, NS2, NEQ

! TO PREVENT UNUSED VARIABLE WARNING
IF(DEBUG) THEN
   WRITE(LU_ERR,*)" TIME= ",TN_C
   DUMMY => FN_VGETARRAYPOINTER(TMP1)
   DUMMY => FN_VGETARRAYPOINTER(TMP2)
   DUMMY => FN_VGETARRAYPOINTER(TMP3)
   IF (.NOT. C_ASSOCIATED(C_USER_DATA)) WRITE(LU_ERR,*)" NO USER_DATA IS PROVIDED"
ENDIF


! GET DATA ARRAYS FROM SUNDIALS VECTORS
TN = REAL(TN_C, KIND=KIND(EB))
CVEC => FN_VGETARRAYPOINTER(SUNVEC_Y)
FVEC => FN_VGETARRAYPOINTER(SUNVEC_F)
CALL C_F_POINTER(C_USER_DATA, USER_DATA)
JMAT = 0._EB
CALL JACOBIAN(CVEC, FVEC, JMAT, TN, USER_DATA)

NEQ = N_TRACKED_SPECIES +2
JMAT1D => FSUNDENSEMATRIX_DATA(SUNMAT_J)
DO NS1=1, NEQ
   DO NS2=1, NEQ
      JMAT1D((NS1-1)*NEQ+NS2)=JMAT(NS1,NS2)
   ENDDO
ENDDO

! RETURN SUCCESS
IERR = 0
RETURN

END FUNCTION JACFN


!> \brief Calculate the analytical jacobian jmat[n_tracked_species+2,n_tracked_species+2]
!> \param CVEC is the current array of molar concentrations, temperature and pressure.
!> \param FVEC is the array of derivatives passed as input
!> \param JMAT is the jacobian matrix returned

SUBROUTINE JACOBIAN(CVEC,FVEC,JMAT,TN,USER_DATA)

USE PHYSICAL_FUNCTIONS, ONLY : GET_SPECIFIC_HEAT_INTERP, GET_SPECIFIC_HEAT_Z,  GET_ENTHALPY, & 
             GET_ENTHALPY_Z, GET_SPECIFIC_HEAT_TMP_DERIVATIVE, MOLAR_CONC_TO_MASS_FRAC, GET_MOLECULAR_WEIGHT

REAL(EB), POINTER, INTENT(INOUT) :: CVEC(:)
REAL(EB), POINTER, INTENT(INOUT) :: FVEC(:)
REAL(EB), INTENT(INOUT) :: JMAT(N_TRACKED_SPECIES+2, N_TRACKED_SPECIES+2)
REAL(EB), INTENT(IN) :: TN
TYPE(USERDATA), INTENT(IN):: USER_DATA

REAL(EB) :: R_F,DCVEC1,DCVEC2, MIN_SPEC(N_TRACKED_SPECIES), KG,  TMP, RHO, &
            K_0, K_INF, P_RI, FCENT, B_I, RRTMP, THIRD_BODY_ENHANCEMENT, PR
REAL(EB) :: ZZ(N_TRACKED_SPECIES), CP_I(N_TRACKED_SPECIES), HS_I(N_TRACKED_SPECIES)
REAL(EB) :: DKCDTBYKC, DBIDC(N_TRACKED_SPECIES), DBIDT, CP, DCPDT, DKINFDTMPBYKINF, DTMPDT, DG, TMPI, RHOI, CPI
REAL(EB) :: ZETA, MIXING_FACTOR, SUM_OMEGA_DOT, SUM_CC, SUM_OMEGA_DOT_BY_CC, SUM_CC_I, ENRG_TERM, DUMMY1, DUMMY2, DUMMY3
REAL(EB) :: VOL_CHANGE_TERM1, VOL_CHANGE_TERM2, VOL_CHANGE_TERM3, VOL_CHANGE_TERM, SUM_DOMEGA_DOT_BY_DT, MW0, MW, &
            SUM_CP_ZZ0,SUM_H_ZZ0, EXPONENT, CONC, CONC_EXP
INTEGER :: I,NS, NS1, NS2, ITMP
TYPE(REACTION_TYPE), POINTER :: RN

TMP = MAX(CVEC(N_TRACKED_SPECIES+1), MIN_CHEM_TMP)
TMPI = 1._EB/TMP
PR = CVEC(N_TRACKED_SPECIES+2) ! PA
RRTMP = 1._EB/(R0*TMP)
ZETA = USER_DATA%ZETA0*EXP(-TN/USER_DATA%TAU_MIX)
MIXING_FACTOR = 0._EB
IF (ZETA < 1._EB) MIXING_FACTOR = ZETA/(1-ZETA)/USER_DATA%TAU_MIX

CALL GET_MOLECULAR_WEIGHT(USER_DATA%ZZ_0,MW0)
IF (ANY(CVEC(1:N_TRACKED_SPECIES) >0)) THEN 
   RHO = DOT_PRODUCT(SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%MW,CVEC(1:N_TRACKED_SPECIES))
   CALL MOLAR_CONC_TO_MASS_FRAC(CVEC(1:N_TRACKED_SPECIES), ZZ(1:N_TRACKED_SPECIES))
   CALL GET_MOLECULAR_WEIGHT(ZZ(1:N_TRACKED_SPECIES),MW)
ELSE ! Enters at the first timestep when ZETA0=1.
   RHO = PR*MW0/R0/TMP
   MW = MW0
   ZZ(1:N_TRACKED_SPECIES) = USER_DATA%ZZ_0(1:N_TRACKED_SPECIES)
ENDIF
RHOI = 1._EB/RHO
MIN_SPEC = SPECIES_MIXTURE%ODE_REL_ERROR*ZZ_MIN_GLOBAL

! TO PREVENT UNUSED VARIABLE WARNING
IF(DEBUG) WRITE(LU_ERR,*)" SIZE OF FVEC ARRAY=", SIZE(FVEC)

! CALCULATE D[X]DOT/D[X] AND D[X]DOT/DT - Take contributions from every reactions 
REACTION_LOOP: DO I=1,N_REACTIONS
   DBIDC = 0._EB
   DBIDT = 0._EB

   RN => REACTION(I)
   ! CHECK FOR CONSUMED SPECIES
   DO NS=1,RN%N_SMIX_FR
      IF (RN%NU_MW_O_MW_F_FR(NS) < 0._EB .AND. CVEC(RN%NU_INDEX(NS)) < MIN_SPEC(NS)) CYCLE REACTION_LOOP
   ENDDO

   ! CALCULATE FORWARD RATE COEFF.
   K_INF = RN%A_SI*TMP**RN%N_T*EXP(-RN%E*RRTMP) !A_SI IS IN [KMOL/M3]^() UNIT.
   R_F = K_INF
   DKINFDTMPBYKINF = (RN%N_T+RN%E*RRTMP)*TMPI
   IF(RN%REVERSE) THEN ! COMPUTE EQUILIBRIUM CONSTANT
      ITMP = MAX(MIN(I_MAX_TEMP-1,INT(TMP)),0)
      DG = RN%DELTA_G(ITMP) + (TMP-REAL(ITMP,EB))*(RN%DELTA_G(ITMP+1)-RN%DELTA_G(ITMP))
      KG = EXP(DG*TMPI)*(P_STP*RRTMP)**RN%C0_EXP
      R_F = R_F*KG ! KG IS THE CONCENTRATION EQUILIBRIUM CONSTANT OF REVERSE REACTION. 
      DKCDTBYKC = ((RN%DELTA_G(MIN(I_MAX_TEMP,NINT(TMP)))*TMPI + RN%DELTA_S(MIN(I_MAX_TEMP,NINT(TMP))))+RN%C0_EXP)*TMPI 
   ENDIF

   DO NS=1,RN%N_SPEC
      IF (CVEC(YP2ZZ(RN%N_S_INDEX(NS))) < MIN_SPEC(YP2ZZ(RN%N_S_INDEX(NS)))) CYCLE REACTION_LOOP
   ENDDO

   
   ! CALCULATE B_I BASED ON TYPE OF REACTION
   IF (RN%THIRD_BODY) THEN
      IF (RN%N_THIRD > 0) THEN
         THIRD_BODY_ENHANCEMENT =  DOT_PRODUCT(CVEC(1:N_SPECIES),RN%THIRD_EFF(1:N_SPECIES))
      ELSE
         THIRD_BODY_ENHANCEMENT = PR*RRTMP
      ENDIF
      IF (RN%REACTYPE==THREE_BODY_ARRHENIUS_TYPE) THEN
         R_F = R_F * THIRD_BODY_ENHANCEMENT
         IF (THIRD_BODY_ENHANCEMENT > 0) THEN
            DO NS=1,N_TRACKED_SPECIES
               IF (RN%N_THIRD > 0) THEN
                  DBIDC(NS) = RN%THIRD_EFF(NS)/THIRD_BODY_ENHANCEMENT
               ELSE
                  DBIDC(NS) = 1._EB/THIRD_BODY_ENHANCEMENT
               ENDIF   
            ENDDO
         ENDIF   
         DBIDT = -TMPI
      ELSEIF(RN%REACTYPE==FALLOFF_LINDEMANN_TYPE .OR. RN%REACTYPE==FALLOFF_TROE_TYPE) THEN
         K_0 = RN%A_LOW_PR*TMP**(RN%N_T_LOW_PR)*EXP(-RN%E_LOW_PR*RRTMP)
         P_RI = K_0/K_INF*THIRD_BODY_ENHANCEMENT
         FCENT = CALCFCENT(TMP,P_RI, I)
         B_I = P_RI/(1._EB+P_RI)*FCENT
         R_F = R_F * B_I
         IF (THIRD_BODY_ENHANCEMENT > TWO_EPSILON_EB) THEN
            CALL CALC_FALLOFF_DBIDC_AND_DBIDT(TMP, I, K_0, K_INF, P_RI, FCENT, DBIDC, DBIDT)
         ENDIF 
      ENDIF 
   ENDIF

   !Contribution of qi
   DO NS1 = 1, RN%N_SPEC
      ! MULTIPLY WITH MOLAR_CONCENTRATION ^ STOICHIOMETRIC_COEFF
      CONC_EXP = 1.0_EB
      DO NS2=1,RN%N_SPEC
         EXPONENT = RN%N_S(NS2)
         CONC = CVEC(YP2ZZ(RN%N_S_INDEX(NS2)))
         IF (NS2 == NS1) THEN
            CONC_EXP = CONC_EXP * MERGE((CONC+TWO_EPSILON_EB)**(EXPONENT - 1._EB), CONC**(EXPONENT - 1._EB), EXPONENT < 1._EB)
         ELSE
            IF (EXPONENT < 1._EB) THEN
               CONC_EXP = CONC_EXP * CONC * (CONC+TWO_EPSILON_EB)**(EXPONENT - 1._EB)
            ELSE
               CONC_EXP = CONC_EXP * CONC**EXPONENT
            END IF
         ENDIF
      ENDDO

      DO NS=1,RN%N_SMIX_FR
         DCVEC1 = R_F*CONC_EXP*RN%NU_NN(RN%NU_INDEX(NS))*RN%N_S(NS1)
         JMAT((YP2ZZ(RN%N_S_INDEX(NS1))),RN%NU_INDEX(NS)) = &
         JMAT((YP2ZZ(RN%N_S_INDEX(NS1))),RN%NU_INDEX(NS))+ DCVEC1 
      ENDDO   
   ENDDO 

   ! CALCULATE THE REACTION RATE
   DO NS=1,RN%N_SPEC
      EXPONENT = RN%N_S(NS)
      CONC = CVEC(YP2ZZ(RN%N_S_INDEX(NS)))
      IF (EXPONENT < 1._EB) THEN
         R_F = R_F * CONC**(EXPONENT - 1._EB)
         R_F = R_F * CONC
      ELSE
          R_F = R_F * CONC**EXPONENT
      END IF
   ENDDO

   ! Add contribution of C_I
   IF (RN%THIRD_BODY) THEN
      DO NS = 1,N_TRACKED_SPECIES
         IF (abs(DBIDC(NS)) > 0._EB) THEN
            DO NS1=1,RN%N_SMIX_FR
               DCVEC2 = R_F*RN%NU_NN(RN%NU_INDEX(NS1))
               JMAT(NS,(YP2ZZ(RN%NU_INDEX(NS1)))) = &
                   JMAT(NS,(YP2ZZ(RN%NU_INDEX(NS1))))+ DCVEC2 * DBIDC(NS) 
            ENDDO
         ENDIF      
      ENDDO   
   ENDIF   

   ! Populate D[X]DOT/DT
   DO NS=1,RN%N_SMIX_FR
      DCVEC2 = R_F*RN%NU_NN(RN%NU_INDEX(NS))
      JMAT(N_TRACKED_SPECIES+1,RN%NU_INDEX(NS)) = JMAT(N_TRACKED_SPECIES+1,RN%NU_INDEX(NS)) - &
         DCVEC2*TMPI*(RN%RHO_EXPONENT+1) + DCVEC2 * DBIDT
      IF(RN%REVERSE) THEN
         JMAT(N_TRACKED_SPECIES+1,RN%NU_INDEX(NS)) = JMAT(N_TRACKED_SPECIES+1,RN%NU_INDEX(NS)) + &
            DCVEC2*(DKINFDTMPBYKINF - DKCDTBYKC)
      ELSE
         JMAT(N_TRACKED_SPECIES+1,RN%NU_INDEX(NS)) = JMAT(N_TRACKED_SPECIES+1,RN%NU_INDEX(NS)) + &
            DCVEC2*DKINFDTMPBYKINF  
      ENDIF      

   ENDDO

ENDDO REACTION_LOOP

! CALCULATE DTDOT/D[X]
DTMPDT = FVEC(N_TRACKED_SPECIES+1)
CALL GET_SPECIFIC_HEAT_INTERP(ZZ(1:N_TRACKED_SPECIES),CP,TMP)
CPI = 1._EB/CP
CALL GET_SPECIFIC_HEAT_TMP_DERIVATIVE(ZZ(1:N_TRACKED_SPECIES),DCPDT,TMP)
SUM_CP_ZZ0 = 0._EB
SUM_H_ZZ0 = 0._EB
DO NS=1,N_TRACKED_SPECIES ! Store the CP and HS 
   CALL GET_SPECIFIC_HEAT_Z(NS, CP_I(NS), TMP)
   CALL GET_ENTHALPY_Z(NS, TMP,HS_I(NS))
   SUM_CP_ZZ0 = SUM_CP_ZZ0+CP_I(NS)*USER_DATA%ZZ_0(NS) ! Needed later.
   SUM_H_ZZ0 = SUM_H_ZZ0+HS_I(NS)*USER_DATA%ZZ_0(NS) ! Needed later.
   CP_I(NS)=CP_I(NS)*SPECIES_MIXTURE(NS)%MW
   HS_I(NS)=HS_I(NS)*SPECIES_MIXTURE(NS)%MW
ENDDO   

DO NS=1,N_TRACKED_SPECIES
   DO NS2=1,N_TRACKED_SPECIES
      JMAT(NS, N_TRACKED_SPECIES+1) = JMAT(NS, N_TRACKED_SPECIES+1)  + &
         HS_I(NS2)*JMAT(NS,NS2)
   ENDDO
   JMAT(NS, N_TRACKED_SPECIES+1) = JMAT(NS, N_TRACKED_SPECIES+1)  + CP_I(NS)*DTMPDT
   JMAT(NS, N_TRACKED_SPECIES+1) = - JMAT(NS, N_TRACKED_SPECIES+1) / RHO/CP   
ENDDO
      
! CALCULATE DTDOT/DT
DO NS=1,N_TRACKED_SPECIES
   JMAT(N_TRACKED_SPECIES+1, N_TRACKED_SPECIES+1) = JMAT(N_TRACKED_SPECIES+1, N_TRACKED_SPECIES+1) + &
      CP_I(NS)*FVEC(NS) + HS_I(NS)*JMAT(N_TRACKED_SPECIES+1,NS)   
ENDDO   
JMAT(N_TRACKED_SPECIES+1, N_TRACKED_SPECIES+1) = JMAT(N_TRACKED_SPECIES+1, N_TRACKED_SPECIES+1) + &
   RHO*DCPDT*DTMPDT
JMAT(N_TRACKED_SPECIES+1, N_TRACKED_SPECIES+1) = -JMAT(N_TRACKED_SPECIES+1, N_TRACKED_SPECIES+1)/RHO/CP
JMAT(N_TRACKED_SPECIES+1, N_TRACKED_SPECIES+1) = JMAT(N_TRACKED_SPECIES+1, N_TRACKED_SPECIES+1) + DTMPDT*TMPI


! NOW ADD TERMS FOR MIXING AND VOLUME CHANGE
!--------------------------------------------
! SO FAR JMAT(1:N_TRACKED_SPECIES, 1:N_TRACKED_SPECIES) CONTAINS JACOBIAN OF CHEMISTRY PRODUCTION RATE d(OMEGA_K_DOT)/d[X]. 
! THE JMAT(1:N_TRACKED_SPECIES, N_TRACKED_SPECIES+1) CONTAINS DTDOT/D[X] ONLY FOR THE CHEMISTRY PRODUCTION RATE TERM.
! THE JMAT(N_TRACKED_SPECIES+1, 1:N_TRACKED_SPECIES) CONTAINS D[X]DOT/D[X] ONLY FOR THE CHEMISTRY PRODUCTION RATE TERM.
! THE JMAT(N_TRACKED_SPECIES+1, N_TRACKED_SPECIES+1) CONTAINS D[T]DOT/DT ONLY FOR THE CHEMISTRY PRODUCTION RATE TERM.

! NOW CALCULATE THE VOLUME CHANGE TERM
SUM_OMEGA_DOT = SUM(FVEC(1:N_TRACKED_SPECIES))
SUM_CC = SUM(CVEC(1:N_TRACKED_SPECIES))
SUM_DOMEGA_DOT_BY_DT = SUM(JMAT(N_TRACKED_SPECIES+1,1:N_TRACKED_SPECIES))
VOL_CHANGE_TERM1 = 0._EB
VOL_CHANGE_TERM2 = 0._EB
VOL_CHANGE_TERM = 0._EB
SUM_CC_I = 0._EB
IF (SUM_CC > 0._EB) THEN
   SUM_CC_I = 1._EB/SUM_CC
   VOL_CHANGE_TERM1 = SUM_OMEGA_DOT/SUM_CC
   VOL_CHANGE_TERM2 = TMPI*FVEC(N_TRACKED_SPECIES+1)
   VOL_CHANGE_TERM3 = MW/MW0*MIXING_FACTOR
   VOL_CHANGE_TERM = VOL_CHANGE_TERM1 + VOL_CHANGE_TERM2 + VOL_CHANGE_TERM3
ENDIF

! DTDOT/D[X]
ENRG_TERM = SUM_H_ZZ0-USER_DATA%H_IN
DUMMY3 = ENRG_TERM*MIXING_FACTOR*CPI*CPI*RHOI
DO NS=1,N_TRACKED_SPECIES
   DUMMY1 = DUMMY3*(CP*SPECIES_MIXTURE(NS)%MW-CP_I(NS))
   JMAT(NS, N_TRACKED_SPECIES+1) = JMAT(NS, N_TRACKED_SPECIES+1) - DUMMY1
ENDDO

! DTDOT/DT
DUMMY1 = ENRG_TERM*CPI*DCPDT
JMAT(N_TRACKED_SPECIES+1, N_TRACKED_SPECIES+1) = JMAT(N_TRACKED_SPECIES+1, N_TRACKED_SPECIES+1) &
         - MIXING_FACTOR*CPI*(SUM_CP_ZZ0+DUMMY1)

! ! D[X]DOT/D[X] 
DUMMY1 = SUM_CC_I*FVEC(N_TRACKED_SPECIES+1)
DUMMY2 = MIXING_FACTOR/MW0*SUM_CC_I
DO NS=1,N_TRACKED_SPECIES
   SUM_OMEGA_DOT_BY_CC= SUM(JMAT(NS,1:N_TRACKED_SPECIES))
   DO NS2=1,N_TRACKED_SPECIES
      ! Mixing term
      JMAT(NS, NS2) = JMAT(NS, NS2) + SPECIES_MIXTURE(NS)%MW/SPECIES_MIXTURE(NS2)%MW*MIXING_FACTOR*USER_DATA%ZZ_0(NS2) 
      ! Volume change term
      IF (NS == NS2) THEN
         JMAT(NS, NS2) = JMAT(NS, NS2) - VOL_CHANGE_TERM
      ENDIF
      JMAT(NS, NS2) = JMAT(NS, NS2) - CVEC(NS2) * (SUM_CC_I*(SUM_OMEGA_DOT_BY_CC-VOL_CHANGE_TERM1) &
               + TMPI*(JMAT(NS, N_TRACKED_SPECIES+1) + DUMMY1) + (SPECIES_MIXTURE(NS)%MW-MW)*DUMMY2)
   ENDDO
ENDDO

! D[X]DOT/DT  
DUMMY1 = 0._EB
IF (SUM_CC >0) DUMMY1= DUMMY1+SUM_DOMEGA_DOT_BY_DT/SUM_CC
DUMMY1 = DUMMY1+TMPI*JMAT(N_TRACKED_SPECIES+1, N_TRACKED_SPECIES+1)-2*TMPI*TMPI*FVEC(N_TRACKED_SPECIES+1)
DUMMY2 = RHO*TMPI
DO NS=1,N_TRACKED_SPECIES
   JMAT(N_TRACKED_SPECIES+1,NS) = JMAT(N_TRACKED_SPECIES+1,NS) - DUMMY2*USER_DATA%ZZ_0(NS)/SPECIES_MIXTURE(NS)%MW*MIXING_FACTOR 
   JMAT(N_TRACKED_SPECIES+1,NS) = JMAT(N_TRACKED_SPECIES+1,NS) - CVEC(NS)* DUMMY1
ENDDO


! CALL PRINT_JMAT(JMAT)


END SUBROUTINE JACOBIAN


!> \brief Print the component of jacobian matrix
!> \param JMAT is the Jacobian matrix.
SUBROUTINE PRINT_JMAT(JMAT)
REAL(EB), INTENT(IN) :: JMAT(N_TRACKED_SPECIES+2, N_TRACKED_SPECIES+2)
INTEGER :: NS, NS2

WRITE(LU_ERR,*)"------------------------------------------------------"
WRITE(LU_ERR,*)" Printing D[X]DOT/D[X] Jacobian elements...."
WRITE(LU_ERR,*)"------------------------------------------------------"
DO NS=1,N_TRACKED_SPECIES
   DO NS2=1,N_TRACKED_SPECIES
      IF (ABS(JMAT(NS,NS2)) > 0._EB) THEN
         WRITE(LU_ERR,'(A,2I4,5A,ES18.6)') "I,J=",NS, NS2, &
            " D[",TRIM(SPECIES_MIXTURE(NS2)%ID),"]DOT/D[",TRIM(SPECIES_MIXTURE(NS)%ID),"]=",JMAT(NS,NS2)
      ENDIF   
   ENDDO   
ENDDO

WRITE(LU_ERR,*)"------------------------------------------------------"
WRITE(LU_ERR,*)" Printing D[X]DOT/DT Jacobian elements...."
WRITE(LU_ERR,*)"------------------------------------------------------"
DO NS=1,N_TRACKED_SPECIES
   IF (ABS(JMAT(N_TRACKED_SPECIES+1,NS)) > 0._EB) THEN
      WRITE(LU_ERR,'(A,2I4,3A,ES18.6)') "I,J=",N_TRACKED_SPECIES+1, NS, &
         " D[",TRIM(SPECIES_MIXTURE(NS)%ID),"]DOT/D[T]=",JMAT(N_TRACKED_SPECIES+1,NS)
   ENDIF   
ENDDO

WRITE(LU_ERR,*)"------------------------------------------------------"
WRITE(LU_ERR,*)" Printing DTDOT/D[X] Jacobian elements...."
WRITE(LU_ERR,*)"------------------------------------------------------"
DO NS=1,N_TRACKED_SPECIES
   IF (ABS(JMAT(NS, N_TRACKED_SPECIES+1)) > 0._EB) THEN
      WRITE(LU_ERR,'(A,2I4,3A,ES18.6)') "I,J=",NS, N_TRACKED_SPECIES+1, &
         " D[T]DOT/D[",TRIM(SPECIES_MIXTURE(NS)%ID),"]=",JMAT(NS, N_TRACKED_SPECIES+1)
   ENDIF   
ENDDO

WRITE(LU_ERR,*)"------------------------------------------------------"
WRITE(LU_ERR,*)" Printing D[T]DOT/DT Jacobian elements...."
WRITE(LU_ERR,*)"------------------------------------------------------"
IF (ABS(JMAT(N_TRACKED_SPECIES+1, N_TRACKED_SPECIES+1)) > 0._EB) THEN
   WRITE(LU_ERR,'(A,2I4,A,ES18.6)') "I,J=",N_TRACKED_SPECIES+1, N_TRACKED_SPECIES+1, &
      " D[T]DOT/D[T]=",JMAT(N_TRACKED_SPECIES+1, N_TRACKED_SPECIES+1)
ENDIF 
END SUBROUTINE PRINT_JMAT


!> \brief Calculate DBIDC of reactions 
!> \param TMP is the current temperature.
!> \param RNI is the reaction index.
!> \param K0 is the low pressure rate coeff.
!> \param KINF is the high pressure rate coeff.
!> \param PR is the pressure ratio.
!> \param F is the falloff function value.
!> \param DBIDC is the derivative of modification factor w.r.t concentration (out).
!> \param DBIDT is the derivative of modification factor w.r.t temperature (out).

SUBROUTINE CALC_FALLOFF_DBIDC_AND_DBIDT(TMP, RNI, K0, KINF, PR, F, DBIDC, DBIDT)
REAL(EB), INTENT(IN) :: TMP, PR, K0, KINF, F
INTEGER, INTENT(IN) :: RNI
REAL(EB), INTENT(INOUT) :: DBIDC(N_TRACKED_SPECIES)
REAL(EB), INTENT(INOUT) :: DBIDT
REAL(EB) :: DPRDBI, DFDBI, DPRDT, DFDT, RRTMP
INTEGER :: NS
TYPE(REACTION_TYPE), POINTER :: RN

RN => REACTION(RNI)
RRTMP = 1._EB/(R0*TMP)

DO NS=1,N_TRACKED_SPECIES
   DPRDBI = -RN%THIRD_EFF(NS     )*K0/KINF
   DFDBI = 0._EB
   IF (RN%REACTYPE==FALLOFF_TROE_TYPE) THEN
      DFDBI = DDC_TROE(PR, F, DPRDBI, TMP, RNI)
   ENDIF   
   DBIDC(NS) = (DPRDBI/(PR*(1 + PR)) + DFDBI/F)
ENDDO


DPRDT = PR/TMP*( RN%N_T_LOW_PR + RN%E_LOW_PR*RRTMP - RN%N_T - RN%E*RRTMP - 1)
DFDT = 0._EB
IF (RN%REACTYPE==FALLOFF_TROE_TYPE) THEN
   DFDT = DDTMP_TROE(PR, F, DPRDT, TMP, RNI)
ENDIF   
DBIDT = (DPRDT/(PR*(1 + PR)) + DFDT/F)

RETURN
END SUBROUTINE CALC_FALLOFF_DBIDC_AND_DBIDT

!> \brief Calculate derivative of TROE function w.r.t concentration  
!> \param PR is the pressure ratio.
!> \param F is the falloff function value.
!> \param DPRDC is the derivative of TROE function w.r.t concentration.
!> \param TMP is the current temperature.
!> \param RNI is the reaction index
REAL(EB) FUNCTION DDC_TROE(PR, F, DPRDC, TMP, RNI) 
REAL(EB), INTENT(IN) :: PR, F, DPRDC, TMP
INTEGER, INTENT(IN) :: RNI
REAL(EB) :: LOGPR, LOGTEN, LOGFCENT, C, N, DLOGPRDC, DPARENTDC
TYPE(REACTION_TYPE), POINTER :: RN
REAL(EB), PARAMETER :: D=0.14_EB

RN => REACTION(RNI)
LOGPR = LOG10(MAX(PR,  TWO_EPSILON_EB))
LOGTEN = LOG(10.0)
IF (RN%T2_TROE <-1.E20_EB) THEN
   LOGFCENT = LOG10(MAX((1 - RN%A_TROE)*EXP(-TMP*RN%RT3_TROE) + &
              RN%A_TROE*EXP(-TMP*RN%RT1_TROE),TWO_EPSILON_EB))
ELSE
   LOGFCENT = LOG10(MAX((1 - RN%A_TROE)*EXP(-TMP*RN%RT3_TROE) + &
              RN%A_TROE*EXP(-TMP*RN%RT1_TROE) + EXP(-RN%T2_TROE/TMP),TWO_EPSILON_EB))
ENDIF

DLOGPRDC = DPRDC/PR/LOGTEN;
C = -0.4_EB - 0.67_EB*LOGFCENT
N = 0.75_EB - 1.27_EB*LOGFCENT

DPARENTDC = 2.0*(LOGPR + C)/((N - D*(LOGPR + C))**2)*((DLOGPRDC)-(LOGPR + C)*(-D*(DLOGPRDC))/(N - D*(LOGPR + C)))

DDC_TROE = F*LOGTEN * (- LOGFCENT*DPARENTDC/(1.0 + ((LOGPR + C)/(N - D*(LOGPR + C)))**2)**2)

END FUNCTION DDC_TROE




!> \brief Calculate derivative of TROE function w.r.t temperature  
!> \param PR is the pressure ratio.
!> \param F is the falloff function value.
!> \param DPRDT is the derivative of TROE function w.r.t temperature.
!> \param TMP is the current temperature.
!> \param RNI is the reaction index
REAL(EB) FUNCTION DDTMP_TROE(PR, F, DPRDT, TMP, RNI) 
REAL(EB), INTENT(IN) :: PR, F, DPRDT, TMP
INTEGER, INTENT(IN) :: RNI
REAL(EB) :: FCENT, LOGPR, LOGTEN, LOGFCENT, DFCENTDT, C, N, DCDT, DNDT, DPARENTDT, DLOGFCENTDT, DLOGPRDT
TYPE(REACTION_TYPE), POINTER :: RN
REAL(EB), PARAMETER :: D=0.14_EB

RN => REACTION(RNI)
LOGPR = LOG10(MAX(PR, TWO_EPSILON_EB));
LOGTEN = LOG(10.0);
IF (RN%T2_TROE <-1.E20_EB) THEN
   FCENT = MAX((1 - RN%A_TROE)*EXP(-TMP*RN%RT3_TROE) + &
              RN%A_TROE*EXP(-TMP*RN%RT1_TROE),TWO_EPSILON_EB)
   DFCENTDT = (RN%A_TROE - 1)*EXP(-TMP*RN%RT3_TROE)*RN%RT3_TROE - &
              RN%A_TROE*EXP(-TMP*RN%RT1_TROE)*RN%RT1_TROE 
ELSE
   FCENT = MAX((1 - RN%A_TROE)*EXP(-TMP*RN%RT3_TROE) + &
              RN%A_TROE*EXP(-TMP*RN%RT1_TROE) + EXP(-RN%T2_TROE/TMP),TWO_EPSILON_EB)
   DFCENTDT = (RN%A_TROE - 1)*EXP(-TMP*RN%RT3_TROE)*RN%RT3_TROE - &
              RN%A_TROE*EXP(-TMP*RN%RT1_TROE)*RN%RT1_TROE + RN%T2_TROE*EXP(-RN%T2_TROE/TMP)/TMP**2
ENDIF
LOGFCENT = LOG10(FCENT)
DLOGFCENTDT = DFCENTDT/FCENT/LOGTEN;
C = -0.4_EB - 0.67_EB*LOGFCENT
N = 0.75_EB - 1.27_EB*LOGFCENT
DCDT = -0.67*DLOGFCENTDT
DNDT = -1.27*DLOGFCENTDT
DLOGPRDT = DPRDT/PR/LOGTEN

DPARENTDT = 2.0*(LOGPR + C)/((N - D*(LOGPR + C))**2)* &
   ((DLOGPRDT + DCDT) - (LOGPR + C)*(DNDT - D*(DLOGPRDT + DCDT))/(N - D*(LOGPR + C)))

DDTMP_TROE = F*LOGTEN*(DLOGFCENTDT/(1.0 + ((LOGPR + C)/(N - D*(LOGPR + C)))**2) &
          - LOGFCENT*DPARENTDT/(1.0 + ((LOGPR + C)/(N - D*(LOGPR + C)))**2)**2)

END FUNCTION DDTMP_TROE



!> \brief cvode interface for ODE integrator. Call sundials cvode in serial mode.
!> \param CC species mass fraction array
!> \param TMP_IN is the temperature
!> \param PR_IN is the pressure
!> \param ZETA0 is the initial unmixed fraction
!> \param TAU_MIX is Mixing timescale
!> \param CELL_MASS total mass of the cell (mixed + unmixed)
!> \param TCUR is the start time in seconds
!> \param TEND is the end time in seconds
!> \param RTOL is the relative error for all the species (REAL_EB)
!> \param ATOL is the absolute error tolerance array for the species (REAL_EB)
!> \param TMP_OUT reactor calculated temperature at the end
!> \param CHEM_TIME Chemical time scale
!> \param WRITE_SUBSTEPS Whether to write cvode substeps. Only write for first cfd step.
!> \param CVODE_CALL_OPTION 1:CV_NORMAL, 2=CV_ONE_STEP
!> \details This is the interface subroutine to the other modules.

SUBROUTINE CVODE_SERIAL(CC,ZZ_0, TMP_IN, PR_IN, ZETA0, TAU_MIX, CELL_MASS, TCUR,TEND, RTOL, ATOL, &
                        TMP_OUT, CHEM_TIME, WRITE_SUBSTEPS, CVODE_CALL_OPTION)
USE PHYSICAL_FUNCTIONS, ONLY : MOLAR_CONC_TO_MASS_FRAC, CALC_EQUIV_RATIO, GET_ENTHALPY, GET_MOLECULAR_WEIGHT
USE COMP_FUNCTIONS, ONLY: GET_FILE_NUMBER
USE GLOBAL_CONSTANTS
USE FCVODE_MOD                 ! FORTRAN INTERFACE TO CVODE
USE FSUNDIALS_CONTEXT_MOD      ! FORTRAN INTERFACE TO SUNCONTEXT
USE FNVECTOR_SERIAL_MOD        ! FORTRAN INTERFACE TO SERIAL N_VECTOR
USE FSUNMATRIX_DENSE_MOD       ! FORTRAN INTERFACE TO DENSE SUNMATRIX
USE FSUNLINSOL_DENSE_MOD       ! FORTRAN INTERFACE TO DENSE SUNLINEARSOLVER
USE FSUNDIALS_LINEARSOLVER_MOD ! FORTRAN INTERFACE TO GENERIC SUNLINEARSOLVER
USE FSUNDIALS_MATRIX_MOD       ! FORTRAN INTERFACE TO GENERIC SUNMATRIX
USE FSUNDIALS_NVECTOR_MOD      ! FORTRAN INTERFACE TO GENERIC N_VECTOR

REAL(EB), INTENT(INOUT) :: CC(N_TRACKED_SPECIES)
REAL(EB), INTENT(IN)    :: ZZ_0(N_TRACKED_SPECIES),TMP_IN,PR_IN,ZETA0,TAU_MIX,CELL_MASS,TCUR,TEND
REAL(EB), INTENT(IN)    :: ATOL(N_TRACKED_SPECIES)
REAL(EB), INTENT(IN)    :: RTOL
REAL(EB), INTENT(OUT)   :: TMP_OUT,CHEM_TIME
INTEGER, INTENT(IN) :: CVODE_CALL_OPTION
LOGICAL, INTENT(IN) :: WRITE_SUBSTEPS

! C-INTERFACE VARIABLES
REAL(C_DOUBLE)                 :: TCUR_C(1)      ! CURRENT TIME
INTEGER(C_INT)                 :: IERR_C         ! ERROR FLAG FROM C FUNCTIONS
REAL(C_DOUBLE)                 :: RTOL_C         ! RELATIVE AND ABSOLUTE TOLERANCE
REAL(C_DOUBLE)                 :: CVEC_C(N_TRACKED_SPECIES+2)    ! N_SP + 2 (FOR TEMPERATURE AND PRESSURE)
REAL(C_DOUBLE)                 :: ATOLVEC_C(N_TRACKED_SPECIES+2) ! N_SP + 2 
INTEGER(C_LONG)                :: MAXSTEPS_C     ! MAXIMUM NUMBER OF INTERNAL STEPS
INTEGER(C_INT)                 :: MAXORD_C       ! Maximum number of order.
INTEGER(C_INT64_T)             :: NEQ
REAL(C_DOUBLE)                 :: CHEM_TIME_C(1)    ! OUTPUT CHEMICAL TIME

! SUNDIALS RELATED VARIABLES
TYPE(C_PTR)                    :: SUNCTX       ! SUNDIALS SIMULATION CONTEXT
TYPE(C_PTR)                    :: CVODE_MEM    ! CVODE MEMORY
TYPE(N_VECTOR),        POINTER :: SUNVEC_Y     ! SUNDIALS VECTOR
TYPE(SUNMATRIX),       POINTER :: SUNMAT_A     ! SUNDIALS MATRIX
TYPE(SUNLINEARSOLVER), POINTER :: SUNLINSOL_LS ! SUNDIALS LINEAR SOLVER
TYPE(N_VECTOR),        POINTER :: SUNATOL      ! SUNDIALS VECTOR FOR ABSOLUTE TOLERANCE
TYPE(C_PTR)                    :: USERDATAPTR  ! USER DATA CONTAINS MIXING INFORMATION

REAL(EB) :: ZZ(N_TRACKED_SPECIES), EQUIV, H_IN
INTEGER :: CVODE_TASK, NS, NTRY, MAXTRY, SUBSTEP_COUNT
REAL(EB) :: H_G
TYPE(USERDATA), TARGET :: USER_DATA
LOGICAL :: ONLY_FIRST_STEP=.TRUE. ! Needed in CV_ONE_STEP


!======= INTERNALS ============
NEQ = INT(N_TRACKED_SPECIES+2, KIND(8))
TCUR_C = TCUR
CVEC_C(1:N_TRACKED_SPECIES) = CC
CVEC_C(N_TRACKED_SPECIES+1) = TMP_IN
CVEC_C(N_TRACKED_SPECIES+2) = PR_IN
ATOLVEC_C(1:N_TRACKED_SPECIES) = ATOL
ATOLVEC_C(N_TRACKED_SPECIES+1) = 0.001_EB
ATOLVEC_C(N_TRACKED_SPECIES+2) = 0.001_EB

! CREATE SUNDIALS CONTEXT
IERR_C = FSUNCONTEXT_CREATE(C_NULL_PTR, SUNCTX)

! CREATE SUNDIALS N_VECTOR
SUNVEC_Y => FN_VMAKE_SERIAL(NEQ, CVEC_C, SUNCTX)
IF (.NOT. ASSOCIATED(SUNVEC_Y)) THEN
   WRITE(LU_ERR,*) 'ERROR: SUNVEC = NULL'
   STOP 1
END IF

! CREATE A DENSE MATRIX
SUNMAT_A => FSUNDENSEMATRIX(NEQ, NEQ, SUNCTX)
IF (.NOT. ASSOCIATED(SUNMAT_A)) THEN
   WRITE(LU_ERR,*)'ERROR: SUNMAT = NULL'
   STOP 1
END IF

! CREATE A DENSE LINEAR SOLVER
SUNLINSOL_LS => FSUNLINSOL_DENSE(SUNVEC_Y, SUNMAT_A, SUNCTX)
IF (.NOT. ASSOCIATED(SUNLINSOL_LS)) THEN
   WRITE(LU_ERR,*) 'ERROR: SUNLINSOL = NULL'
   STOP 1
END IF

! CREATE CVODE MEMORY
CVODE_MEM = FCVODECREATE(CV_BDF, SUNCTX)
IF (.NOT. C_ASSOCIATED(CVODE_MEM)) THEN
   WRITE(LU_ERR,*) 'ERROR: CVODE_MEM = NULL'
   STOP 1
END IF

! INITIALIZE CVODE
IERR_C = FCVODEINIT(CVODE_MEM, C_FUNLOC(RHSFN), TCUR_C(1), SUNVEC_Y)
IF (IERR_C /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODEINIT, IERR = ', IERR_C, '; HALTING'
   STOP 1
END IF

! SET RELATIVE AND ABSOLUTE TOLERANCES
RTOL_C = RTOL
SUNATOL => FN_VMAKE_SERIAL(NEQ, ATOLVEC_C, SUNCTX)
IERR_C = FCVODESVTOLERANCES(CVODE_MEM, RTOL_C, SUNATOL)
IF (IERR_C /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODESSTOLERANCES, IERR = ', IERR_C, '; HALTING'
   STOP 1
END IF

! ATTACH LINEAR SOLVER
IERR_C = FCVODESETLINEARSOLVER(CVODE_MEM, SUNLINSOL_LS, SUNMAT_A);
IF (IERR_C /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODESETLINEARSOLVER, IERR = ', IERR_C, '; HALTING'
   STOP 1
END IF

! SET JACOBIAN ROUTINE
IERR_C = FCVODESETJACFN(CVODE_MEM, C_FUNLOC(JACFN))
IF (IERR_C /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODESETJACFN, IERR = ', IERR_C, '; HALTING'
   STOP 1
END IF

! SET MAX NUM OF STEPS
MAXSTEPS_C = MAX_CVODE_SUBSTEPS
IERR_C = FCVODESETMAXNUMSTEPS(CVODE_MEM, MAXSTEPS_C)
IF (IERR_C /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODESETMAXNUMSTEPS, IERR = ', IERR_C, '; HALTING'
   STOP 1
END IF

! SET MAX ORDER
MAXORD_C = 5
IF (IS_EXPONENT_LT_1) MAXORD_C = 1
IERR_C = FCVODESETMAXORD(CVODE_MEM, MAXORD_C)
IF (IERR_C /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODESETMAXORD, IERR = ', IERR_C, '; HALTING'
   STOP 1
END IF

! SET ERROR HANDLER
IERR_C = FCVODESETERRHANDLERFN(CVODE_MEM, C_FUNLOC(FDS_CVODE_ERR_HANDLER), C_NULL_PTR)
IF (IERR_C /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODESETMAXNUMSTEPS, IERR = ', IERR_C, '; HALTING'
   STOP 1
END IF

! SET USER DATA
USER_DATA%ZETA0 = ZETA0
USER_DATA%TAU_MIX = TAU_MIX
USER_DATA%CELL_MASS = CELL_MASS
ALLOCATE(USER_DATA%ZZ_0(N_TRACKED_SPECIES))
USER_DATA%ZZ_0 = ZZ_0
CALL GET_ENTHALPY(ZZ_0,H_IN,TMP_IN)
USER_DATA%H_IN = H_IN 
USERDATAPTR = C_LOC(USER_DATA)
IERR_C = FCVODESETUSERDATA(CVODE_MEM, USERDATAPTR)

!CALL CVODE
CVODE_TASK = CV_NORMAL
IF(CVODE_CALL_OPTION ==2) THEN
   CVODE_TASK = CV_ONE_STEP
ENDIF

IF (CVODE_TASK == CV_NORMAL) THEN
   IERR_C = FCVODE(CVODE_MEM, TEND, SUNVEC_Y, TCUR_C, CVODE_TASK)
ELSE IF(CVODE_TASK == CV_ONE_STEP) THEN
   ONLY_FIRST_STEP = .TRUE.
   IF (WRITE_SUBSTEPS) THEN ! This WRITE_SUBSTEPS is only true for few verification cases.
      ONLY_FIRST_STEP = .FALSE.
      IF (.NOT. ALLOCATED(CVODE_SUBSTEP_DATA)) &
          ALLOCATE(CVODE_SUBSTEP_DATA((CVODE_MAX_TRY+1)*MAX_CVODE_SUBSTEPS, N_TRACKED_SPECIES+4))
   ENDIF
   
   SUBSTEP_COUNT = 0
   DO WHILE (TCUR_C(1) < TEND)
      SUBSTEP_COUNT = SUBSTEP_COUNT + 1
      IERR_C = FCVODE(CVODE_MEM, TEND, SUNVEC_Y, TCUR_C, CVODE_TASK)
      IF (IERR_C /= 0) THEN
         WRITE(LU_ERR,'(A, I4, A, 2E18.8, A)')" ERROR: CVODE didn't finish ODE solution in CV_ONE_STEP mode with message code:",&
                        IERR_C," and CUR_CFD_TIME, DT=", CUR_CFD_TIME, (TEND-TCUR), "."
         STOP
      ENDIF
      IF (ONLY_FIRST_STEP) EXIT 
      IF (WRITE_SUBSTEPS) THEN
         CALL MOLAR_CONC_TO_MASS_FRAC(CVEC_C(1:N_TRACKED_SPECIES), ZZ(1:N_TRACKED_SPECIES))
         CALL GET_ENTHALPY(ZZ(1:N_TRACKED_SPECIES),H_G,CVEC_C(N_TRACKED_SPECIES+1))
         CVODE_SUBSTEP_DATA(SUBSTEP_COUNT,1:4) = [TCUR_C(1), CVEC_C(N_TRACKED_SPECIES+1)-TMPM, CVEC_C(N_TRACKED_SPECIES+2), H_G]
         CVODE_SUBSTEP_DATA(SUBSTEP_COUNT,5:N_TRACKED_SPECIES+4) = ZZ(1:N_TRACKED_SPECIES)
      ENDIF  
   END DO


ENDIF

IF (IERR_C /= 0) THEN
   MAXTRY = CVODE_MAX_TRY
   ! If all internal substeps are taken try two more times. This will allow larger CFD timestep.
   IF (IERR_C == CV_TOO_MUCH_WORK) THEN !CV_TOO_MUCH_WORK == all internal substeps are taken
      NTRY = 0
      DO WHILE (NTRY < MAXTRY)
         IERR_C = FCVODE(CVODE_MEM, TEND, SUNVEC_Y, TCUR_C, CV_NORMAL)
         IF (IERR_C == CV_TOO_MUCH_WORK) THEN
            NTRY = NTRY +1
            CYCLE
         ELSE
            EXIT
         ENDIF
      ENDDO
   ENDIF

   IF (IERR_C .NE. CV_SUCCESS) THEN
      IF (IERR_C == CV_TOO_MUCH_WORK) THEN
         WRITE(LU_ERR,'(A, 2E18.8, A)')" WARN: CVODE took all internal substeps. CUR_CFD_TIME, DT=", CUR_CFD_TIME, (TEND-TCUR), &
                     ". If the warning persists, reduce the timestep."
      ELSE
         WRITE(LU_ERR,'(A, I4, A, 2E18.8, A)')" WARN: CVODE didn't finish ODE solution with message code:", IERR_C, &
                        " and CUR_CFD_TIME, DT=", CUR_CFD_TIME, (TEND-TCUR), ". If the warning persists, reduce the timestep."
      ENDIF   

      IF (DEBUG) THEN
         CALL MOLAR_CONC_TO_MASS_FRAC(CC(1:N_TRACKED_SPECIES), ZZ(1:N_TRACKED_SPECIES))
         CALL CALC_EQUIV_RATIO(ZZ(1:N_TRACKED_SPECIES), EQUIV)
         DO NS = 1, N_TRACKED_SPECIES
            WRITE(LU_ERR,*)" ID, Y=",SPECIES_MIXTURE(NS)%ID, ZZ(NS)
         ENDDO 
         WRITE(LU_ERR,*)" EQUIVALENCE RATIO, TMP=", EQUIV,TMP_IN
         CALL CVODESTATS(CVODE_MEM) ! DIAGNOSTICS OUTPUT
      ENDIF   
   ENDIF   
ENDIF

CC = CVEC_C(1:N_TRACKED_SPECIES) !DISCARD THE TEMPERATURE.
TMP_OUT = CVEC_C(N_TRACKED_SPECIES+1)
IERR_C = FCVODEGETLASTSTEP(CVODE_MEM, CHEM_TIME_C(1))
CHEM_TIME=CHEM_TIME_C(1)

! CLEAN UP
DEALLOCATE(USER_DATA%ZZ_0)
CALL FCVODEFREE(CVODE_MEM)
IERR_C = FSUNLINSOLFREE(SUNLINSOL_LS)
CALL FSUNMATDESTROY(SUNMAT_A)
CALL FN_VDESTROY(SUNVEC_Y)
CALL FN_VDESTROY(SUNATOL)
IERR_C = FSUNCONTEXT_FREE(SUNCTX)

IF (WRITE_SUBSTEPS) THEN
   TOTAL_SUBSTEPS_TAKEN = SUBSTEP_COUNT
   STOP_STATUS=CVODE_SUBSTEP_STOP
   RETURN
ENDIF


END SUBROUTINE CVODE_SERIAL


!> \brief CVODE error handler callback function, such that CVODE() doesn't output the error directly to stderr.
!> \param ERR_CODE The error code send by CVODE
!> \param MOD_NAME The module name where error occured send by CVODE
!> \param FUNC_NAME The functio name where error occured send by CVODE
!> \param MESSAGE The error message
!> \param USER_DATA User data, not used in FDS.
SUBROUTINE FDS_CVODE_ERR_HANDLER( ERR_CODE, MOD_NAME, FUNC_NAME, MESSAGE, USER_DATA) &
   BIND(C,NAME='FDS_CVODE_ERR_HANDLER')
INTEGER(C_INT), VALUE :: ERR_CODE
CHARACTER(KIND=C_CHAR),DIMENSION(*),INTENT(IN) :: MOD_NAME
CHARACTER(KIND=C_CHAR),DIMENSION(*),INTENT(IN) :: FUNC_NAME
CHARACTER(KIND=C_CHAR),DIMENSION(*),INTENT(IN) :: MESSAGE
TYPE(C_PTR), VALUE    :: USER_DATA        ! USER-DEFINED DATA
CHARACTER(LEN=200) :: TEMP_STRING
LOGICAL :: FOUND_NULL
INTEGER :: J


IF (DEBUG) THEN
   WRITE(LU_ERR,'(A, E18.8)')" WARN: CVODE message at CFD time. CUR_CFD_TIME=", CUR_CFD_TIME
   WRITE(LU_ERR,*) '  CVODE CODE   : ', ERR_CODE

   ! Print Message
   FOUND_NULL = .FALSE.
   TEMP_STRING = ''
   J = 1
   DO WHILE (.NOT. FOUND_NULL)
       IF (MESSAGE(J) == C_NULL_CHAR) THEN
           FOUND_NULL = .TRUE.
       ELSE
           TEMP_STRING(J:J) = MESSAGE(J)
           J = J + 1
       END IF
   END DO
   WRITE(LU_ERR,*) 'CVODE MESSAGE : ', TRIM(TEMP_STRING)

   ! Print MOD_NAME
   FOUND_NULL = .FALSE.
   TEMP_STRING = ''
   J = 1
   DO WHILE (.NOT. FOUND_NULL)
       IF (MOD_NAME(J) == C_NULL_CHAR) THEN
           FOUND_NULL = .TRUE.
       ELSE
           TEMP_STRING(J:J) = MOD_NAME(J)
           J = J + 1
       END IF
   END DO
   WRITE(LU_ERR,*) '  MODULE       : ', TRIM(TEMP_STRING)

   ! Print func name
   FOUND_NULL = .FALSE.
   TEMP_STRING = ''
   J = 1
   DO WHILE (.NOT. FOUND_NULL)
       IF (FUNC_NAME(J) == C_NULL_CHAR) THEN
           FOUND_NULL = .TRUE.
       ELSE
           TEMP_STRING(J:J) = FUNC_NAME(J)
           J = J + 1
       END IF
   END DO
   WRITE(LU_ERR,*) '  FUNCTION     : ', TRIM(TEMP_STRING)

   IF (.NOT. C_ASSOCIATED(USER_DATA)) WRITE(LU_ERR,*)" NO USER_DATA IS PROVIDED"
ENDIF

END SUBROUTINE FDS_CVODE_ERR_HANDLER



!> \brief print CVODE statistics from a CVODE memory object.
!> \param CVODE_MEM CVODE memory object.
SUBROUTINE CVODESTATS(CVODE_MEM)

!======= INCLUSIONS ===========
USE ISO_C_BINDING
USE FCVODE_MOD
USE GLOBAL_CONSTANTS

TYPE(C_PTR), INTENT(IN) :: CVODE_MEM ! SOLVER MEMORY STRUCTURE

INTEGER(C_INT)  :: IERR          ! ERROR FLAG

INTEGER(C_LONG) :: NSTEPS(1)     ! NUM STEPS
INTEGER(C_LONG) :: NFEVALS(1)    ! NUM FUNCTION EVALS
INTEGER(C_LONG) :: NLINSETUPS(1) ! NUM LINEAR SOLVER SETUPS
INTEGER(C_LONG) :: NETFAILS(1)   ! NUM ERROR TEST FAILS

INTEGER(C_INT)  :: QLAST(1)      ! METHOD ORDER IN LAST STEP
INTEGER(C_INT)  :: QCUR(1)       ! METHOD ORDER FOR NEXT STEP

REAL(C_DOUBLE)  :: HINUSED(1)    ! INITIAL STEP SIZE
REAL(C_DOUBLE)  :: HLAST(1)      ! LAST STEP SIZE
REAL(C_DOUBLE)  :: HCUR(1)       ! STEP SIZE FOR NEXT STEP
REAL(C_DOUBLE)  :: TCUR(1)       ! INTERNAL TIME REACHED

INTEGER(C_LONG) :: NNITERS(1)    ! NONLINEAR SOLVER ITERATIONS
INTEGER(C_LONG) :: NNCFAILS(1)   ! NONLINEAR SOLVER FAILS

INTEGER(C_LONG) :: NJEVALS(1)    ! NUM JACOBIAN EVALUATIONS

!======= INTERNALS ============

! GENERAL SOLVER STATISTICS
IERR = FCVODEGETINTEGRATORSTATS(CVODE_MEM, NSTEPS, NFEVALS, NLINSETUPS, &
    NETFAILS, QLAST, QCUR, HINUSED, HLAST, HCUR, TCUR)
IF (IERR /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODEGETINTEGRATORSTATS, IERR = ', IERR, '; HALTING'
   STOP 1
END IF

! NONLINEAR SOLVER STATISTICS
IERR = FCVODEGETNONLINSOLVSTATS(CVODE_MEM, NNITERS, NNCFAILS)
IF (IERR /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODEGETNONLINSOLVSTATS, IERR = ', IERR, '; HALTING'
   STOP 1
END IF

! NUMBER OF JACOBIAN EVALUATIONS
IERR = FCVODEGETNUMJACEVALS(CVODE_MEM, NJEVALS)
IF (IERR /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODEGETNUMJACEVALS, IERR = ', IERR, '; HALTING'
   STOP 1
END IF

WRITE(LU_ERR,*) ' '
WRITE(LU_ERR,*) ' GENERAL SOLVER STATS:'
WRITE(LU_ERR,'(4X,A,I9)')    'TOTAL INTERNAL STEPS TAKEN =',NSTEPS
WRITE(LU_ERR,'(4X,A,I9)')    'TOTAL RHS FUNCTION CALLS   =',NFEVALS
WRITE(LU_ERR,'(4X,A,I9)')    'NUM LIN SOLVER SETUP CALLS =',NLINSETUPS
WRITE(LU_ERR,'(4X,A,I9)')    'NUM ERROR TEST FAILURES    =',NETFAILS
WRITE(LU_ERR,'(4X,A,I9)')    'LAST METHOD ORDER          =',QLAST
WRITE(LU_ERR,'(4X,A,I9)')    'NEXT METHOD ORDER          =',QCUR
WRITE(LU_ERR,'(4X,A,ES12.5)')'FIRST INTERNAL STEP SIZE   =',HINUSED
WRITE(LU_ERR,'(4X,A,ES12.5)')'LAST INTERNAL STEP SIZE    =',HLAST
WRITE(LU_ERR,'(4X,A,ES12.5)')'NEXT INTERNAL STEP SIZE    =',HCUR
WRITE(LU_ERR,'(4X,A,ES12.5)')'CURRENT INTERNAL TIME      =',TCUR
WRITE(LU_ERR,'(4X,A,I9)')    'NUM NONLINEAR SOLVER ITERS =',NNITERS
WRITE(LU_ERR,'(4X,A,I9)')    'NUM NONLINEAR SOLVER FAILS =',NNCFAILS
WRITE(LU_ERR,'(4X,A,I9)')    'NUM JACOBIAN EVALUATIONS   =',NJEVALS
WRITE(LU_ERR,*) ' '

RETURN

END SUBROUTINE CVODESTATS

END MODULE CVODE_INTERFACE
!> @cond DOXYGEN_IGNORE
#endif
!> @endcond

