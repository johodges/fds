! CALL CVODE FOR SOLVING CHEMISTRY 
! THE DERIVATIVE AND JACOBIAN FUNCTION TRACK N_TRACKED_SPECIES+2
! VARIABLES. THE +2 IS TEMPERATURE AND PRESSURE.


#ifdef WITH_SUNDIALS

MODULE CVODE_INTERFACE

USE PRECISION_PARAMETERS
USE GLOBAL_CONSTANTS   
USE TYPES
USE DVODECONS
USE, INTRINSIC :: ISO_C_BINDING

IMPLICIT NONE

LOGICAL :: DEBUG=.FALSE.

PUBLIC CVODE_SERIAL

CONTAINS

  
!> \brief The right hand side function of the ode d[c]/dt = wdot (=f).
!> \param TN_C is the current time
!> \param SUNVEC_Y is the current array of molar concentrations, temperature and pressure.
!> \param SUNVEC_F is the array of derivatives returned

INTEGER(C_INT) FUNCTION RHSFN(TN_C, SUNVEC_Y, SUNVEC_F, USER_DATA) &
    RESULT(IERR) BIND(C,NAME='RHSFN')

USE, INTRINSIC :: ISO_C_BINDING
USE FSUNDIALS_NVECTOR_MOD

! CALLING VARIABLES
REAL(C_DOUBLE), VALUE :: TN_C      ! CURRENT TIME
TYPE(N_VECTOR)        :: SUNVEC_Y  ! SOLUTION N_VECTOR
TYPE(N_VECTOR)        :: SUNVEC_F  ! RHS N_VECTOR
TYPE(C_PTR),    VALUE :: USER_DATA ! USER-DEFINED DATA

! POINTERS TO DATA IN SUNDIALS VECTORS
REAL(EB), POINTER :: CVEC(:)
REAL(EB), POINTER :: FVEC(:)

! TO PREVENT UNUSED VARIABLE WARNING
IF (DEBUG) THEN
   WRITE(LU_ERR,*)"TIME = ",TN_C
   IF (.NOT. C_ASSOCIATED(USER_DATA)) WRITE(LU_ERR,*)" NO USER_DATA IS PROVIDED"
ENDIF

! GET DATA ARRAYS FROM SUNDIALS VECTORS
CVEC => FN_VGETARRAYPOINTER(SUNVEC_Y)
FVEC => FN_VGETARRAYPOINTER(SUNVEC_F)

FVEC = 0._EB
CALL DERIVATIVE(CVEC, FVEC)

IERR = 0
RETURN

END FUNCTION RHSFN



!> \brief Calculate derivative (fvec) for a given cvec(n_tracked_species+2)
!> \param CVEC is the current array of molar concentrations, temperature and pressure.
!> \param FVEC is the array of derivatives returned

SUBROUTINE DERIVATIVE(CVEC,FVEC)
USE PHYSICAL_FUNCTIONS, ONLY : GET_SPECIFIC_HEAT, GET_ENTHALPY_Z 

REAL(EB), POINTER, INTENT(INOUT)  :: CVEC(:)
REAL(EB), POINTER, INTENT(INOUT) :: FVEC(:)
REAL(EB) :: R_F,MIN_SPEC(N_TRACKED_SPECIES), KG,  TMP, RHO, &
          K_0, K_INF, P_RI, FCENT, C_I, RRTMP, THIRD_BODY_ENHANCEMENT
INTEGER :: I,NS
TYPE(REACTION_TYPE), POINTER :: RN=>NULL()

TMP = CVEC(N_TRACKED_SPECIES+1)
PR = CVEC(N_TRACKED_SPECIES+2) ! PA
RRTMP = 1._EB/(R0*TMP)

RHO = DOT_PRODUCT(SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%MW,CVEC(1:N_TRACKED_SPECIES))
MIN_SPEC = SPECIES_MIXTURE%ODE_REL_ERROR*ZZ_MIN_GLOBAL

REACTION_LOOP: DO I=1,N_REACTIONS
   RN => REACTION(I)
   ! CHECK FOR CONSUMED SPECIES
   DO NS=1,RN%N_SMIX_FR
      IF (RN%NU_MW_O_MW_F_FR(NS) < 0._EB .AND. CVEC(RN%NU_INDEX(NS)) < MIN_SPEC(NS)) CYCLE REACTION_LOOP
   ENDDO

   ! CALCULATE FORWARD RATE COEFF.
   K_INF = RN%A_SI*TMP**RN%N_T*EXP(-RN%E*RRTMP) !A_SI IS IN [KMOL/M3]^() UNIT.
   R_F = K_INF
   IF(RN%REVERSE) THEN ! COMPUTE EQUILIBRIUM CONSTANT
      KG = EXP(RN%DELTA_G(MIN(I_MAX_TEMP,NINT(TMP)))/TMP)*(P_STP*RRTMP)**RN%C0_EXP
      R_F = R_F*KG ! KG IS THE CONCENTRATION EQUILIBRIUM CONSTANT OF REVERSE REACTION. 
   ENDIF

   ! MULTIPLY WITH MOLAR_CONCENTRATION ^ STOICHIOMETRIC_COEFF
   DO NS=1,RN%N_SPEC
      IF (CVEC(YP2ZZ(RN%N_S_INDEX(NS))) < MIN_SPEC(YP2ZZ(RN%N_S_INDEX(NS)))) CYCLE REACTION_LOOP
      R_F = R_F*(CVEC(YP2ZZ(RN%N_S_INDEX(NS))))**RN%N_S(NS) 
   ENDDO

   ! CALCULATE CI BASED ON TYPE OF REACTION
   IF (RN%THIRD_BODY) THEN

      IF (RN%N_THIRD > 0) THEN
         THIRD_BODY_ENHANCEMENT = DOT_PRODUCT(CVEC(1:N_SPECIES),RN%THIRD_EFF(1:N_SPECIES))
      ELSE
         THIRD_BODY_ENHANCEMENT = PR*RRTMP
      ENDIF

      IF (RN%REACTYPE==THREE_BODY_ARRHENIUS_TYPE) THEN
         R_F = R_F * THIRD_BODY_ENHANCEMENT
      ELSEIF(RN%REACTYPE==FALLOFF_LINDEMANN_TYPE .OR. RN%REACTYPE==FALLOFF_TROE_TYPE ) THEN
         K_0 = RN%A_LOW_PR*TMP**(RN%N_T_LOW_PR)*EXP(-RN%E_LOW_PR*RRTMP)
         P_RI = K_0/K_INF*THIRD_BODY_ENHANCEMENT
         FCENT = CALCFCENT(TMP,P_RI, RN)
         C_I = P_RI/(1._EB+P_RI)*FCENT
         R_F = R_F * C_I
      ENDIF 
   ENDIF

   IF (DEBUG) WRITE(LU_ERR,*)"RN%ID, RATE-CONTRIB=", RN%ID, R_F

   ! ADD CONTRIBUTION OF THE REACTION TO THE FVEC
   DO NS=1,RN%N_SMIX_FR
     FVEC(RN%NU_INDEX(NS)) = FVEC(RN%NU_INDEX(NS)) + RN%NU_NN(RN%NU_INDEX(NS)) * R_F
   ENDDO
ENDDO REACTION_LOOP

! FOR NOW TEMPERATURE DERIVATIVE IS ZERO. WORK IN PROGRESS TO IMPLEMENT IT IN NEXT RELEASE.
FVEC(N_TRACKED_SPECIES+1)=0.0

! PRESSURE DERIVATIVE (CONSTANT PRESSURE ASSUMPTION)
FVEC(N_TRACKED_SPECIES+2) = 0._EB
END SUBROUTINE DERIVATIVE


!> \brief Calculate fall-off function 
!> \param TMP is the current temperature.
!> \param P_RI is the reduced pressure
!> \param RN is the reaction

REAL(EB) FUNCTION CALCFCENT(TMP, P_RI, RN)
REAL(EB), INTENT(IN) :: TMP, P_RI
TYPE(REACTION_TYPE), POINTER, INTENT(IN) :: RN
REAL(EB) :: LOGFCENT, C, N, LOGPRC
REAL(EB), PARAMETER :: D=0.14_EB

IF(RN%REACTYPE==FALLOFF_TROE_TYPE) THEN
   IF (RN%T2_TROE <-1.E20_EB) THEN
      LOGFCENT = LOG10(MAX((1 - RN%A_TROE)*EXP(-TMP*RN%RT3_TROE) + &
                 RN%A_TROE*EXP(-TMP*RN%RT1_TROE),TWO_EPSILON_EB))
   ELSE
      LOGFCENT = LOG10(MAX((1 - RN%A_TROE)*EXP(-TMP*RN%RT3_TROE) + &
                 RN%A_TROE*EXP(-TMP*RN%RT1_TROE) + EXP(-RN%T2_TROE/TMP),TWO_EPSILON_EB))
   ENDIF
   C = -0.4_EB - 0.67_EB*LOGFCENT
   N = 0.75_EB - 1.27_EB*LOGFCENT
   LOGPRC = LOG10(MAX(P_RI, TWO_EPSILON_EB)) + C
   CALCFCENT = 10._EB**(LOGFCENT/(1._EB + (LOGPRC/(N - D*LOGPRC))**2))
ELSE
   CALCFCENT = 1._EB  !FALLOFF-LINDEMANNN
ENDIF

RETURN

END FUNCTION CALCFCENT




!> \the jacobian of the ode right hand side function j = df/dy
!> \param TN_C is the current time
!> \param SUNVEC_Y is the current array of molar concentrations, temperature and pressure.
!> \param SUNVEC_F is the array of derivatives returned

INTEGER(C_INT) FUNCTION JACFN(TN_C, SUNVEC_Y, SUNVEC_F, SUNMAT_J, &
 USER_DATA, TMP1, TMP2, TMP3) &
 RESULT(IERR) BIND(C,NAME='JACFN')

USE, INTRINSIC :: ISO_C_BINDING
USE FSUNDIALS_NVECTOR_MOD
USE FSUNMATRIX_DENSE_MOD
USE FSUNDIALS_MATRIX_MOD

! CALLING VARIABLES
REAL(C_DOUBLE), VALUE :: TN_C             ! CURRENT TIME
TYPE(N_VECTOR)        :: SUNVEC_Y         ! CURRENT SOLUTION N_VECTOR
TYPE(N_VECTOR)        :: SUNVEC_F         ! CURRENT RHS N_VECTOR
TYPE(SUNMATRIX)       :: SUNMAT_J         ! JACOBIAN SUNMATRIX
TYPE(C_PTR), VALUE    :: USER_DATA        ! USER-DEFINED DATA
TYPE(N_VECTOR)        :: TMP1, TMP2, TMP3 ! WORKSPACE N_VECTORS

! POINTER TO DATA IN SUNDIALS MATRIX
REAL(EB), POINTER :: CVEC(:)
REAL(EB), POINTER :: FVEC(:)
REAL(EB), POINTER :: JMAT1D(:)
REAL(EB) :: JMAT(N_TRACKED_SPECIES+2, N_TRACKED_SPECIES+2)
REAL(EB), POINTER :: DUMMY(:)

INTEGER :: NS1, NS2, NEQ

! TO PREVENT UNUSED VARIABLE WARNING
IF(DEBUG) THEN
   WRITE(LU_ERR,*)" TIME= ",TN_C
   DUMMY => FN_VGETARRAYPOINTER(TMP1)
   DUMMY => FN_VGETARRAYPOINTER(TMP2)
   DUMMY => FN_VGETARRAYPOINTER(TMP3)
   IF (.NOT. C_ASSOCIATED(USER_DATA)) WRITE(LU_ERR,*)" NO USER_DATA IS PROVIDED"
ENDIF


! GET DATA ARRAYS FROM SUNDIALS VECTORS
CVEC => FN_VGETARRAYPOINTER(SUNVEC_Y)
FVEC => FN_VGETARRAYPOINTER(SUNVEC_F)
JMAT = 0._EB
CALL JACOBIAN(CVEC, FVEC, JMAT)

NEQ = N_TRACKED_SPECIES +2
JMAT1D => FSUNDENSEMATRIX_DATA(SUNMAT_J)
DO NS1=1, NEQ
   DO NS2=1, NEQ
      JMAT1D((NS1-1)*NEQ+NS2)=JMAT(NS1,NS2)
   ENDDO
ENDDO

! RETURN SUCCESS
IERR = 0
RETURN

END FUNCTION JACFN


!> \brief Calculate the jacobian matrix (jmat[n_tracked_species+2,
!> \param CVEC is the current array of molar concentrations, temperature and pressure.
!> \param FVEC is the array of derivatives passed as input
!> \param JMAT is the jacobian matrix returned

SUBROUTINE JACOBIAN(CVEC,FVEC, JMAT)

USE PHYSICAL_FUNCTIONS, ONLY : GET_SPECIFIC_HEAT, GET_SPECIFIC_HEAT_Z,  & 
             GET_ENTHALPY_Z, GET_SPECIFIC_HEAT_TEMP_DERIVATIVE

REAL(EB), POINTER, INTENT(INOUT) :: CVEC(:)
REAL(EB), POINTER, INTENT(INOUT) :: FVEC(:)
REAL(EB), INTENT(INOUT) :: JMAT(N_TRACKED_SPECIES+2, N_TRACKED_SPECIES+2)

REAL(EB) :: R_F,DCVEC,MIN_SPEC(N_TRACKED_SPECIES), KG,  TMP, RHO, &
            K_0, K_INF, P_RI, FCENT, C_I, RRTMP, THIRD_BODY_ENHANCEMENT
INTEGER :: I,NS, NS2
TYPE(REACTION_TYPE), POINTER :: RN=>NULL()

TMP = CVEC(N_TRACKED_SPECIES+1)
PR = CVEC(N_TRACKED_SPECIES+2) ! PA
RRTMP = 1._EB/(R0*TMP)

RHO = DOT_PRODUCT(SPECIES_MIXTURE(1:N_TRACKED_SPECIES)%MW,CVEC(1:N_TRACKED_SPECIES))
MIN_SPEC = SPECIES_MIXTURE%ODE_REL_ERROR*ZZ_MIN_GLOBAL

! TO PREVENT UNUSED VARIABLE WARNING
IF(DEBUG) WRITE(LU_ERR,*)" SIZE OF FVEC ARRAY=", SIZE(FVEC)

! CALCULATE DYDOT/DY
REACTION_LOOP: DO I=1,N_REACTIONS
   RN => REACTION(I)
   ! CHECK FOR CONSUMED SPECIES
   DO NS=1,RN%N_SMIX_FR
      IF (RN%NU_MW_O_MW_F_FR(NS) < 0._EB .AND. CVEC(RN%NU_INDEX(NS)) < MIN_SPEC(NS)) CYCLE REACTION_LOOP
   ENDDO

   ! CALCULATE FORWARD RATE COEFF.
   K_INF = RN%A_SI*TMP**RN%N_T*EXP(-RN%E*RRTMP) !A_SI IS IN [KMOL/M3]^() UNIT.
   R_F = K_INF
   IF(RN%REVERSE) THEN ! COMPUTE EQUILIBRIUM CONSTANT
      KG = EXP(RN%DELTA_G(MIN(I_MAX_TEMP,NINT(TMP)))/TMP)*(P_STP*RRTMP)**RN%C0_EXP
      R_F = R_F*KG ! KG IS THE CONCENTRATION EQUILIBRIUM CONSTANT OF REVERSE REACTION. 
   ENDIF

   ! MULTIPLY WITH MOLAR_CONCENTRATION ^ STOICHIOMETRIC_COEFF
   DO NS=1,RN%N_SPEC
      IF (CVEC(YP2ZZ(RN%N_S_INDEX(NS))) < MIN_SPEC(YP2ZZ(RN%N_S_INDEX(NS)))) CYCLE REACTION_LOOP
      R_F = R_F*(CVEC(YP2ZZ(RN%N_S_INDEX(NS))))**RN%N_S(NS)
   ENDDO

   ! CALCULATE CI BASED ON TYPE OF REACTION
   IF (RN%THIRD_BODY) THEN

      IF (RN%N_THIRD > 0) THEN
         THIRD_BODY_ENHANCEMENT =  DOT_PRODUCT(CVEC(1:N_SPECIES),RN%THIRD_EFF(1:N_SPECIES))
      ELSE
         THIRD_BODY_ENHANCEMENT = PR*RRTMP
      ENDIF

      IF (RN%REACTYPE==THREE_BODY_ARRHENIUS_TYPE) THEN
         R_F = R_F * THIRD_BODY_ENHANCEMENT
      ELSEIF(RN%REACTYPE==FALLOFF_LINDEMANN_TYPE .OR. RN%REACTYPE==FALLOFF_TROE_TYPE) THEN
         K_0 = RN%A_LOW_PR*TMP**(RN%N_T_LOW_PR)*EXP(-RN%E_LOW_PR*RRTMP)
         P_RI = K_0/K_INF*THIRD_BODY_ENHANCEMENT
         FCENT = CALCFCENT(TMP,P_RI, RN)
         C_I = P_RI/(1._EB+P_RI)*FCENT
         R_F = R_F * C_I
      ENDIF 
   ENDIF

   DO NS=1,RN%N_SMIX_FR
      DCVEC = R_F * RN%NU_NN(RN%NU_INDEX(NS))
      DO NS2 = 1, RN%N_SPEC
         JMAT((YP2ZZ(RN%N_S_INDEX(NS2))),RN%NU_INDEX(NS)) = &
         JMAT((YP2ZZ(RN%N_S_INDEX(NS2))),RN%NU_INDEX(NS))+ &
         DBLE(RN%N_S(NS2) * DCVEC / CVEC(YP2ZZ(RN%N_S_INDEX(NS2)) ))
      ENDDO
   ENDDO
ENDDO REACTION_LOOP

END SUBROUTINE JACOBIAN

!> \cvode interface for ODE integrator 
!> \Call sundials cvode in serial mode.
!> \param ZZ species mass fraction array
!> \param TMP_IN is the temperature
!> \param PR_IN is the pressure
!> \param TCUR is the start time in seconds
!> \param TEND is the end time in seconds
!> \param RTOL is the relative error for all the species (REAL_EB)
!> \param ATOL is the absolute error tolerance array for the species (REAL_EB)

SUBROUTINE CVODE_SERIAL(CC,TMP_IN, PR_IN, TCUR,TEND, RTOL, ATOL)
USE, INTRINSIC :: ISO_C_BINDING
USE GLOBAL_CONSTANTS
USE FCVODE_MOD                 ! FORTRAN INTERFACE TO CVODE
USE FSUNDIALS_CONTEXT_MOD      ! FORTRAN INTERFACE TO SUNCONTEXT
USE FNVECTOR_SERIAL_MOD        ! FORTRAN INTERFACE TO SERIAL N_VECTOR
USE FSUNMATRIX_DENSE_MOD       ! FORTRAN INTERFACE TO DENSE SUNMATRIX
USE FSUNLINSOL_DENSE_MOD       ! FORTRAN INTERFACE TO DENSE SUNLINEARSOLVER
USE FSUNDIALS_LINEARSOLVER_MOD ! FORTRAN INTERFACE TO GENERIC SUNLINEARSOLVER
USE FSUNDIALS_MATRIX_MOD       ! FORTRAN INTERFACE TO GENERIC SUNMATRIX
USE FSUNDIALS_NVECTOR_MOD      ! FORTRAN INTERFACE TO GENERIC N_VECTOR

REAL(EB), INTENT(INOUT) :: CC(N_TRACKED_SPECIES)
REAL(EB), INTENT(IN)    :: TMP_IN, PR_IN,  TCUR, TEND
REAL(EB), INTENT(IN)    :: ATOL(N_TRACKED_SPECIES)
REAL(EB), INTENT(IN)    :: RTOL

! C-INTERFACE VARIABLES
REAL(C_DOUBLE)                 :: TCUR_C(1)      ! CURRENT TIME
INTEGER(C_INT)                 :: IERR_C         ! ERROR FLAG FROM C FUNCTIONS
REAL(C_DOUBLE)                 :: RTOL_C         ! RELATIVE AND ABSOLUTE TOLERANCE
REAL(C_DOUBLE)                 :: CVEC_C(N_TRACKED_SPECIES+2)    ! N_SP + 2 (FOR TEMPERATURE AND PRESSURE)
REAL(C_DOUBLE)                 :: ATOLVEC_C(N_TRACKED_SPECIES+2) ! N_SP + 2 
INTEGER(C_LONG)                :: MAXSTEPS_C     ! MAXIMUM NUMBER OF INTERNAL STEPS
INTEGER(C_LONG)                :: NEQ

! SUNDIALS RELATED VARIABLES
TYPE(C_PTR)                    :: SUNCTX       ! SUNDIALS SIMULATION CONTEXT
TYPE(C_PTR)                    :: CVODE_MEM    ! CVODE MEMORY
TYPE(N_VECTOR),        POINTER :: SUNVEC_Y     ! SUNDIALS VECTOR
TYPE(SUNMATRIX),       POINTER :: SUNMAT_A     ! SUNDIALS MATRIX
TYPE(SUNLINEARSOLVER), POINTER :: SUNLINSOL_LS ! SUNDIALS LINEAR SOLVER
TYPE(N_VECTOR),        POINTER :: SUNATOL      ! SUNDIALS VECTOR FOR ABSOLUTE TOLERANCE



!======= INTERNALS ============
NEQ = INT(N_TRACKED_SPECIES+2, KIND(8))
TCUR_C = TCUR
CVEC_C(1:N_TRACKED_SPECIES) = CC
CVEC_C(N_TRACKED_SPECIES+1) = TMP_IN
CVEC_C(N_TRACKED_SPECIES+2) = PR_IN
ATOLVEC_C(1:N_TRACKED_SPECIES) = ATOL
ATOLVEC_C(N_TRACKED_SPECIES+1) = 0.001_EB
ATOLVEC_C(N_TRACKED_SPECIES+2) = 0.001_EB

! CREATE SUNDIALS CONTEXT
IERR_C = FSUNCONTEXT_CREATE(C_NULL_PTR, SUNCTX)

! CREATE SUNDIALS N_VECTOR
SUNVEC_Y => FN_VMAKE_SERIAL(NEQ, CVEC_C, SUNCTX)
IF (.NOT. ASSOCIATED(SUNVEC_Y)) THEN
   WRITE(LU_ERR,*) 'ERROR: SUNVEC = NULL'
   STOP 1
END IF

! CREATE A DENSE MATRIX
SUNMAT_A => FSUNDENSEMATRIX(NEQ, NEQ, SUNCTX)
IF (.NOT. ASSOCIATED(SUNMAT_A)) THEN
   WRITE(LU_ERR,*)'ERROR: SUNMAT = NULL'
   STOP 1
END IF

! CREATE A DENSE LINEAR SOLVER
SUNLINSOL_LS => FSUNLINSOL_DENSE(SUNVEC_Y, SUNMAT_A, SUNCTX)
IF (.NOT. ASSOCIATED(SUNLINSOL_LS)) THEN
   WRITE(LU_ERR,*) 'ERROR: SUNLINSOL = NULL'
   STOP 1
END IF

! CREATE CVODE MEMORY
CVODE_MEM = FCVODECREATE(CV_BDF, SUNCTX)
IF (.NOT. C_ASSOCIATED(CVODE_MEM)) THEN
   WRITE(LU_ERR,*) 'ERROR: CVODE_MEM = NULL'
   STOP 1
END IF

! INITIALIZE CVODE
IERR_C = FCVODEINIT(CVODE_MEM, C_FUNLOC(RHSFN), TCUR_C(1), SUNVEC_Y)
IF (IERR_C /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODEINIT, IERR = ', IERR_C, '; HALTING'
   STOP 1
END IF

! SET RELATIVE AND ABSOLUTE TOLERANCES
RTOL_C = RTOL
SUNATOL => FN_VMAKE_SERIAL(NEQ, ATOLVEC_C, SUNCTX)
IERR_C = FCVODESVTOLERANCES(CVODE_MEM, RTOL_C, SUNATOL)
IF (IERR_C /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODESSTOLERANCES, IERR = ', IERR_C, '; HALTING'
   STOP 1
END IF

! ATTACH LINEAR SOLVER
IERR_C = FCVODESETLINEARSOLVER(CVODE_MEM, SUNLINSOL_LS, SUNMAT_A);
IF (IERR_C /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODESETLINEARSOLVER, IERR = ', IERR_C, '; HALTING'
   STOP 1
END IF

! SET JACOBIAN ROUTINE
IERR_C = FCVODESETJACFN(CVODE_MEM, C_FUNLOC(JACFN))
IF (IERR_C /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODESETJACFN, IERR = ', IERR_C, '; HALTING'
   STOP 1
END IF

! SET MAX NUM OF STEPS
MAXSTEPS_C = 50000
IERR_C = FCVODESETMAXNUMSTEPS(CVODE_MEM, MAXSTEPS_C)
IF (IERR_C /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODESETMAXNUMSTEPS, IERR = ', IERR_C, '; HALTING'
   STOP 1
END IF

!CALL CVODE
IERR_C = FCVODE(CVODE_MEM, TEND, SUNVEC_Y, TCUR_C, CV_NORMAL)
IF (IERR_C /= 0) CALL CVODESTATS(CVODE_MEM) ! DIAGNOSTICS OUTPUT

CC = CVEC_C(1:N_TRACKED_SPECIES) !DISCARD THE TEMPERATURE.

! CLEAN UP
CALL FCVODEFREE(CVODE_MEM)
IERR_C = FSUNLINSOLFREE(SUNLINSOL_LS)
CALL FSUNMATDESTROY(SUNMAT_A)
CALL FN_VDESTROY(SUNVEC_Y)
IERR_C = FSUNCONTEXT_FREE(SUNCTX)

END SUBROUTINE CVODE_SERIAL  


!> \brief Print cvode statstics to standard out

SUBROUTINE CVODESTATS(CVODE_MEM)

!======= INCLUSIONS ===========
USE ISO_C_BINDING
USE FCVODE_MOD
USE GLOBAL_CONSTANTS

TYPE(C_PTR), INTENT(IN) :: CVODE_MEM ! SOLVER MEMORY STRUCTURE

INTEGER(C_INT)  :: IERR          ! ERROR FLAG

INTEGER(C_LONG) :: NSTEPS(1)     ! NUM STEPS
INTEGER(C_LONG) :: NFEVALS(1)    ! NUM FUNCTION EVALS
INTEGER(C_LONG) :: NLINSETUPS(1) ! NUM LINEAR SOLVER SETUPS
INTEGER(C_LONG) :: NETFAILS(1)   ! NUM ERROR TEST FAILS

INTEGER(C_INT)  :: QLAST(1)      ! METHOD ORDER IN LAST STEP
INTEGER(C_INT)  :: QCUR(1)       ! METHOD ORDER FOR NEXT STEP

REAL(C_DOUBLE)  :: HINUSED(1)    ! INITIAL STEP SIZE
REAL(C_DOUBLE)  :: HLAST(1)      ! LAST STEP SIZE
REAL(C_DOUBLE)  :: HCUR(1)       ! STEP SIZE FOR NEXT STEP
REAL(C_DOUBLE)  :: TCUR(1)       ! INTERNAL TIME REACHED

INTEGER(C_LONG) :: NNITERS(1)    ! NONLINEAR SOLVER ITERATIONS
INTEGER(C_LONG) :: NNCFAILS(1)   ! NONLINEAR SOLVER FAILS

INTEGER(C_LONG) :: NJEVALS(1)    ! NUM JACOBIAN EVALUATIONS

!======= INTERNALS ============

! GENERAL SOLVER STATISTICS
IERR = FCVODEGETINTEGRATORSTATS(CVODE_MEM, NSTEPS, NFEVALS, NLINSETUPS, &
    NETFAILS, QLAST, QCUR, HINUSED, HLAST, HCUR, TCUR)
IF (IERR /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODEGETINTEGRATORSTATS, IERR = ', IERR, '; HALTING'
   STOP 1
END IF

! NONLINEAR SOLVER STATISTICS
IERR = FCVODEGETNONLINSOLVSTATS(CVODE_MEM, NNITERS, NNCFAILS)
IF (IERR /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODEGETNONLINSOLVSTATS, IERR = ', IERR, '; HALTING'
   STOP 1
END IF

! NUMBER OF JACOBIAN EVALUATIONS
IERR = FCVODEGETNUMJACEVALS(CVODE_MEM, NJEVALS)
IF (IERR /= 0) THEN
   WRITE(LU_ERR,*) 'ERROR IN FCVODEGETNUMJACEVALS, IERR = ', IERR, '; HALTING'
   STOP 1
END IF

WRITE(LU_ERR,*) ' '
WRITE(LU_ERR,*) ' GENERAL SOLVER STATS:'
WRITE(LU_ERR,'(4X,A,I9)')    'TOTAL INTERNAL STEPS TAKEN =',NSTEPS
WRITE(LU_ERR,'(4X,A,I9)')    'TOTAL RHS FUNCTION CALLS   =',NFEVALS
WRITE(LU_ERR,'(4X,A,I9)')    'NUM LIN SOLVER SETUP CALLS =',NLINSETUPS
WRITE(LU_ERR,'(4X,A,I9)')    'NUM ERROR TEST FAILURES    =',NETFAILS
WRITE(LU_ERR,'(4X,A,I9)')    'LAST METHOD ORDER          =',QLAST
WRITE(LU_ERR,'(4X,A,I9)')    'NEXT METHOD ORDER          =',QCUR
WRITE(LU_ERR,'(4X,A,ES12.5)')'FIRST INTERNAL STEP SIZE   =',HINUSED
WRITE(LU_ERR,'(4X,A,ES12.5)')'LAST INTERNAL STEP SIZE    =',HLAST
WRITE(LU_ERR,'(4X,A,ES12.5)')'NEXT INTERNAL STEP SIZE    =',HCUR
WRITE(LU_ERR,'(4X,A,ES12.5)')'CURRENT INTERNAL TIME      =',TCUR
WRITE(LU_ERR,'(4X,A,I9)')    'NUM NONLINEAR SOLVER ITERS =',NNITERS
WRITE(LU_ERR,'(4X,A,I9)')    'NUM NONLINEAR SOLVER FAILS =',NNCFAILS
WRITE(LU_ERR,'(4X,A,I9)')    'NUM JACOBIAN EVALUATIONS   =',NJEVALS
WRITE(LU_ERR,*) ' '

RETURN

END SUBROUTINE CVODESTATS

END MODULE CVODE_INTERFACE
#endif
